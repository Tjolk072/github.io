<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
  <meta name="docker_version" content="1.6.1">
  <meta name="docker_git_branch" content="master">
  <meta name="docker_git_commit" content="59cd467">
  <meta name="docker_build_date" content="Fri Jun  5 11:40:50 UTC 2015">

  <meta name="description" content="Docker networking">
  <meta name="keywords" content="network, networking, bridge, docker, documentation">
  
  <link rel="canonical" href="/articles/networking/">
  <link href="/css/bootstrap-custom.css" rel="stylesheet">
  <link href="/css/main.css" rel="stylesheet">
  <link href="/css/prettify-1.0.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/dockerfile_tutorial.css">
  <link href="/tipuesearch
/tipuesearch.css" rel="stylesheet">
  <link href="/css/docs.css" rel="stylesheet">
  <link rel="shortcut icon" href="/img/favicon.png">
  <title>Advanced networking - Docker Documentation</title>
  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
  <![endif]-->
  
  <script type="text/javascript">
	  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="4.0.0";
	  analytics.load("IWj9D0UpZHZdZUZX9jl98PcpBFWBnBMy");
	  analytics.page();
	  }}();
	</script>
  
</head>
<body>

<div id="topmostnav" class="topmostnav_loggedout navbar navbar-static-top">
  <div class="container">
    <a href="/" title="Docker Docs Home"><div class="brand logo"><img src="/img/nav/docker-logo-loggedin.png"> </div></a>
    <form id="nav_search" class="navbar-index-search pull-right" action="/jsearch/">
      <span role="status" aria-live="polite" class="ui-helper-hidden-accessible"></span>
      <input name="q" id="tipue_search_input" type="text" class="search_input search-query ui-autocomplete-input" placeholder="Search the Docs" autocomplete="off">
    </form>
    <ul class="nav">
      <li class=""><a href="http://www.docker.com/whatisdocker/" title="What is Docker">What is Docker?</a></li>
      <li class=""><a href="http://www.docker.com/resources/usecases/" title="Use Cases">Use Cases</a></li>
      <li class=""><a href="http://www.docker.com/tryit/" title="Try It!">Try It!</a></li>
      <li><a href="https://registry.hub.docker.com" title="Browse">Browse</a></li>
    </ul>
    <div id="usernav" class="pull-right">
      <a href="https://hub.docker.com/account/login" class="btn nav-button2" title="Lg In">Log In</a>
      <a href="https://hub.docker.com/account/signup" class="btn nav-button1" title="Sign Up">Sign Up</a>
    </div>
  </div>
</div>
<div id="topmostnav" class="topmostnav_loggedin navbar navbar-static-top">
  <div class="container">
    <a href="/" title="Docker Docs Home"><div class="brand logo"><img src="/img/nav/docker-logo-loggedin.png"> </div></a>
    <form id="nav_search" class="navbar-index-search pull-right" action="/jsearch/">
      <span role="status" aria-live="polite" class="ui-helper-hidden-accessible"></span>
      <input name="q" id="tipue_search_input" type="text" class="search_input search-query ui-autocomplete-input" placeholder="Search the Docs" autocomplete="off">
    </form>
    <ul class="nav">
      <li><a href="https://registry.hub.docker.com" title="Browse Repos">Browse Repos</a></li>
      <li class="active"><a href="http://docs.docker.com" title="Documentation">Documentation</a></li>
      <li><a href="http://www.docker.com/community/participate/" title="Community">Community</a></li>
      <li><a href="http://www.docker.com/resources/help/" title="Help">Help</a></li>
    </ul>
    <div id="usernav" class="pull-right">
      <ul class="nav user">
        <li class="dropdown">
          <a id="logged-in-header-username" class="dropdown-toggle" data-toggle="dropdown" href="#">
            <img class="profile" src="" alt="profile picture">
          </a>
          <ul class="dropdown-menu pull-right">
            <li><a href="https://hub.docker.com/">View Profile</a></li>
            <li><a href="https://hub.docker.com/account/settings/">Settings</a></li>
            <li><a href="https://hub.docker.com/repos/">My Repositories</a></li>
            <li><a href="https://hub.docker.com/plans/billing-info">Billing</a></li>
            <li><a href="https://hub.docker.com/account/logout/?next=/">Log out</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
</div>

<div id="wrap">
  <nav id="nav_menu" class="clearfix navbar navbar-default navbar-static-top affix" role="navigation">
  <div id="docsnav">
    <ul id="main-nav" class="pull-left">
      
      
      <li class="dd_menu pull-left">
        
        <a href="/">About</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/">Docker</a>
          </li>
        
          <li >
            <a href="/release-notes/">Release Notes</a>
          </li>
        
          <li >
            <a href="/introduction/understanding-docker/">Understanding Docker</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/installation/ubuntulinux/">Installation</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/installation/ubuntulinux/">Ubuntu</a>
          </li>
        
          <li >
            <a href="/installation/mac/">Mac OS X</a>
          </li>
        
          <li >
            <a href="/kitematic/">Kitematic on OS X</a>
          </li>
        
          <li >
            <a href="/installation/windows/">Microsoft Windows</a>
          </li>
        
          <li >
            <a href="/installation/testing-windows-docker-client/">Building and testing the Windows Docker client</a>
          </li>
        
          <li >
            <a href="/installation/amazon/">Amazon EC2</a>
          </li>
        
          <li >
            <a href="/installation/archlinux/">Arch Linux</a>
          </li>
        
          <li >
            <a href="/installation/binaries/">Binaries</a>
          </li>
        
          <li >
            <a href="/installation/centos/">CentOS</a>
          </li>
        
          <li >
            <a href="/installation/cruxlinux/">CRUX Linux</a>
          </li>
        
          <li >
            <a href="/installation/debian/">Debian</a>
          </li>
        
          <li >
            <a href="/installation/fedora/">Fedora</a>
          </li>
        
          <li >
            <a href="/installation/frugalware/">FrugalWare</a>
          </li>
        
          <li >
            <a href="/installation/google/">Google Cloud Platform</a>
          </li>
        
          <li >
            <a href="/installation/gentoolinux/">Gentoo</a>
          </li>
        
          <li >
            <a href="/installation/softlayer/">IBM Softlayer</a>
          </li>
        
          <li >
            <a href="/installation/joyent/">Joyent Compute Service</a>
          </li>
        
          <li >
            <a href="/installation/azure/">Microsoft Azure</a>
          </li>
        
          <li >
            <a href="/installation/rackspace/">Rackspace Cloud</a>
          </li>
        
          <li >
            <a href="/installation/rhel/">Red Hat Enterprise Linux</a>
          </li>
        
          <li >
            <a href="/installation/oracle/">Oracle Linux</a>
          </li>
        
          <li >
            <a href="/installation/SUSE/">SUSE</a>
          </li>
        
          <li >
            <a href="/compose/install/">Docker Compose</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/userguide/">User Guide</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/userguide/">The Docker User Guide</a>
          </li>
        
          <li >
            <a href="/userguide/dockerhub/">Getting Started with Docker Hub</a>
          </li>
        
          <li >
            <a href="/userguide/dockerizing/">Dockerizing Applications</a>
          </li>
        
          <li >
            <a href="/userguide/usingdocker/">Working with Containers</a>
          </li>
        
          <li >
            <a href="/userguide/dockerimages/">Working with Docker Images</a>
          </li>
        
          <li >
            <a href="/userguide/dockerlinks/">Linking containers together</a>
          </li>
        
          <li >
            <a href="/userguide/dockervolumes/">Managing data in containers</a>
          </li>
        
          <li >
            <a href="/userguide/labels-custom-metadata/">Apply custom metadata</a>
          </li>
        
          <li >
            <a href="/userguide/dockerrepos/">Working with Docker Hub</a>
          </li>
        
          <li >
            <a href="/compose/">Docker Compose</a>
          </li>
        
          <li >
            <a href="/compose/production/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Use Compose in production</a>
          </li>
        
          <li >
            <a href="/compose/extends/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Extend Compose services</a>
          </li>
        
          <li >
            <a href="/machine/">Docker Machine</a>
          </li>
        
          <li >
            <a href="/swarm/">Docker Swarm</a>
          </li>
        
          <li >
            <a href="/kitematic/userguide/">Kitematic</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/docker-hub/">Docker Hub</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/docker-hub/">Docker Hub</a>
          </li>
        
          <li >
            <a href="/docker-hub/accounts/">Accounts</a>
          </li>
        
          <li >
            <a href="/docker-hub/userguide/">User Guide</a>
          </li>
        
          <li >
            <a href="/docker-hub/repos/">Your Repositories</a>
          </li>
        
          <li >
            <a href="/docker-hub/builds/">Automated Builds</a>
          </li>
        
          <li >
            <a href="/docker-hub/official_repos/">Official Repositories</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/docker-hub-enterprise/">Docker Hub Enterprise</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/docker-hub-enterprise/">Overview</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/quick-start/">Quick Start: Basic Workflow</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/userguide/">User Guide</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/adminguide/">Admin Guide</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/install/">&nbsp;&nbsp;Installation</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/configuration/">&nbsp;&nbsp;Configuration options</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/support/">Support</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/release-notes/">Release notes</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/examples/nodejs_web_app/">Examples</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/examples/nodejs_web_app/">Dockerizing a Node.js web application</a>
          </li>
        
          <li >
            <a href="/examples/mongodb/">Dockerizing MongoDB</a>
          </li>
        
          <li >
            <a href="/examples/running_redis_service/">Dockerizing a Redis service</a>
          </li>
        
          <li >
            <a href="/examples/postgresql_service/">Dockerizing a PostgreSQL service</a>
          </li>
        
          <li >
            <a href="/examples/running_riak_service/">Dockerizing a Riak service</a>
          </li>
        
          <li >
            <a href="/examples/running_ssh_service/">Dockerizing an SSH service</a>
          </li>
        
          <li >
            <a href="/examples/couchdb_data_volumes/">Dockerizing a CouchDB service</a>
          </li>
        
          <li >
            <a href="/examples/apt-cacher-ng/">Dockerizing an Apt-Cacher-ng service</a>
          </li>
        
          <li >
            <a href="/compose/django/">Getting started with Compose and Django</a>
          </li>
        
          <li >
            <a href="/compose/rails/">Getting started with Compose and Rails</a>
          </li>
        
          <li >
            <a href="/compose/wordpress/">Getting started with Compose and Wordpress</a>
          </li>
        
          <li >
            <a href="/kitematic/minecraft-server/">Kitematic: Minecraft server</a>
          </li>
        
          <li >
            <a href="/kitematic/nginx-web-server/">Kitematic: Ngnix web server</a>
          </li>
        
          <li >
            <a href="/kitematic/rethinkdb-dev-database/">Kitematic: RethinkDB development database</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left active">
        
        <a href="/articles/basics/">Articles</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/articles/basics/">Docker basics</a>
          </li>
        
          <li class="active">
            <a href="/articles/networking/">Advanced networking</a>
          </li>
        
          <li >
            <a href="/articles/security/">Security</a>
          </li>
        
          <li >
            <a href="/articles/https/">Running Docker with HTTPS</a>
          </li>
        
          <li >
            <a href="/articles/registry_mirror/">Run a local registry mirror</a>
          </li>
        
          <li >
            <a href="/articles/host_integration/">Automatically starting containers</a>
          </li>
        
          <li >
            <a href="/articles/baseimages/">Creating a base image</a>
          </li>
        
          <li >
            <a href="/articles/dockerfile_best-practices/">Best practices for writing Dockerfiles</a>
          </li>
        
          <li >
            <a href="/articles/certificates/">Using certificates for repository client verification</a>
          </li>
        
          <li >
            <a href="/articles/using_supervisord/">Using Supervisor</a>
          </li>
        
          <li >
            <a href="/articles/configuring/">Configuring Docker</a>
          </li>
        
          <li >
            <a href="/articles/cfengine_process_management/">Process management with CFEngine</a>
          </li>
        
          <li >
            <a href="/articles/puppet/">Using Puppet</a>
          </li>
        
          <li >
            <a href="/articles/chef/">Using Chef</a>
          </li>
        
          <li >
            <a href="/articles/dsc/">Using PowerShell DSC</a>
          </li>
        
          <li >
            <a href="/articles/ambassador_pattern_linking/">Cross-Host linking using ambassador containers</a>
          </li>
        
          <li >
            <a href="/articles/runmetrics/">Runtime metrics</a>
          </li>
        
          <li >
            <a href="/articles/b2d_volume_resize/">Increasing a Boot2Docker volume</a>
          </li>
        
          <li >
            <a href="/articles/systemd/">Controlling and configuring Docker using Systemd</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/reference/commandline/cli/">Reference</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/reference/commandline/cli/">Docker command line</a>
          </li>
        
          <li >
            <a href="/reference/builder/">Dockerfile</a>
          </li>
        
          <li >
            <a href="/faq/">FAQ</a>
          </li>
        
          <li >
            <a href="/reference/run/">Run Reference</a>
          </li>
        
          <li >
            <a href="/compose/cli/">Compose command line</a>
          </li>
        
          <li >
            <a href="/compose/yml/">Compose yml</a>
          </li>
        
          <li >
            <a href="/compose/env/">Compose ENV variables</a>
          </li>
        
          <li >
            <a href="/compose/completion/">Compose commandline completion</a>
          </li>
        
          <li >
            <a href="/swarm/discovery/">Swarm discovery</a>
          </li>
        
          <li >
            <a href="/swarm/scheduler/strategy/">Swarm strategies</a>
          </li>
        
          <li >
            <a href="/swarm/scheduler/filter/">Swarm filters</a>
          </li>
        
          <li >
            <a href="/swarm/API/">Swarm API</a>
          </li>
        
          <li >
            <a href="/registry/">Docker Registry 2.0</a>
          </li>
        
          <li >
            <a href="/registry/deploying/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Deploy a registry</a>
          </li>
        
          <li >
            <a href="/registry/configuration/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Configure a registry</a>
          </li>
        
          <li >
            <a href="/registry/storagedrivers/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Storage driver model</a>
          </li>
        
          <li >
            <a href="/registry/notifications/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Work with notifications</a>
          </li>
        
          <li >
            <a href="/registry/spec/api/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Registry Service API v2</a>
          </li>
        
          <li >
            <a href="/registry/spec/json/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; JSON format</a>
          </li>
        
          <li >
            <a href="/registry/spec/auth/token/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Authenticate via central service</a>
          </li>
        
          <li >
            <a href="/reference/api/hub_registry_spec/">Docker Hub and Registry 1.0</a>
          </li>
        
          <li >
            <a href="/reference/api/registry_api/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp;Docker Registry API v1</a>
          </li>
        
          <li >
            <a href="/reference/api/registry_api_client_libraries/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp;Docker Registry 1.0 API Client Libraries</a>
          </li>
        
          <li >
            <a href="/reference/api/docker-io_api/">Docker Hub API</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api/">Docker Remote API</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api_v1.18/">Docker Remote API v1.18</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api_v1.17/">Docker Remote API v1.17</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api_v1.16/">Docker Remote API v1.16</a>
          </li>
        
          <li >
            <a href="/reference/api/remote_api_client_libraries/">Docker Remote API client libraries</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_io_accounts_api/">Docker Hub accounts API</a>
          </li>
        
          <li >
            <a href="/kitematic/faq/">Kitematic: FAQ</a>
          </li>
        
          <li >
            <a href="/kitematic/known-issues/">Kitematic: Known issues</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/project/who-written-for/">Contributor</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/project/who-written-for/">README first</a>
          </li>
        
          <li >
            <a href="/project/software-required/">Get required software for Linux or OS X</a>
          </li>
        
          <li >
            <a href="/project/software-req-win/">Get required software for Windows</a>
          </li>
        
          <li >
            <a href="/project/set-up-git/">Configure Git for contributing</a>
          </li>
        
          <li >
            <a href="/project/set-up-dev-env/">Work with a development container</a>
          </li>
        
          <li >
            <a href="/project/test-and-docs/">Run tests and test documentation</a>
          </li>
        
          <li >
            <a href="/project/make-a-contribution/">Understand contribution workflow</a>
          </li>
        
          <li >
            <a href="/project/find-an-issue/">Find an issue</a>
          </li>
        
          <li >
            <a href="/project/work-issue/">Work on an issue</a>
          </li>
        
          <li >
            <a href="/project/create-pr/">Create a pull request</a>
          </li>
        
          <li >
            <a href="/project/review-pr/">Participate in the PR review</a>
          </li>
        
          <li >
            <a href="/project/advanced-contributing/">Advanced contributing</a>
          </li>
        
          <li >
            <a href="/project/get-help/">Where to get help</a>
          </li>
        
          <li >
            <a href="/project/coding-style/">Coding style guide</a>
          </li>
        
          <li >
            <a href="/project/doc-style/">Documentation style guide</a>
          </li>
        
        </ul>
      </li>
      
      
    </ul>
  </div>
</nav>
  <div id="content" class="container">
    <div class="row">

      <div class="span3" id="leftnav">
        <div id="toc_table">
          <ul class="nav nav-tabs nav-stacked">
            
  
    <li class=""><a href="#tldr">TL;DR</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#quick-guide-to-the-options">Quick Guide to the Options</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#configuring-dns">Configuring DNS</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#communication-between-containers-and-the-wider-world">Communication between containers and the wider world</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#communication-between-containers">Communication between containers</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#binding-container-ports-to-the-host">Binding container ports to the host</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#ipv6">IPv6</a>
      <ul>
    
      <li><a href="#ipv6-with-docker">IPv6 with Docker</a></li>
    
      <li><a href="#docker-ipv6-cluster">Docker IPv6 Cluster</a></li>
    
      </ul>
    </li>
  
    <li class=""><a href="#customizing-docker0">Customizing docker0</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#building-your-own-bridge">Building your own bridge</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#how-docker-networks-a-container">How Docker networks a container</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#tools-and-examples">Tools and Examples</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#building-a-point-to-point-connection">Building a point-to-point connection</a>
      <ul>
    
      </ul>
    </li>
  
    <li class=""><a href="#editing-networking-config-files">Editing networking config files</a>
      <ul>
    
      </ul>
    </li>
  

          </ul>
        </div>
      </div>
      <div class="span9 content-body">

        

        <div id="versionnav" class="span3 pull-right invisible">
          <ul class="nav version pull-right">
            <li class="dropdown">
              <a id="document-version-number" class="dropdown-toggle" data-toggle="dropdown" href="#">
		      Version v1.6
              </a>
              <ul id="documentation-version-list" class="dropdown-menu pull-right">

		<li role="presentation" class="divider"></li>
		<li> <a class="home-link3 tertiary-nav" href="https://github.com/docker/docker/blob/master/docs/sources/articles/networking.md" >Edit on GitHub</a></li>

              </ul>
            </li>
          </ul>
        </div>

        <h1 id="network-configuration">Network Configuration</h1>
<h2 id="tldr">TL;DR</h2>
<p>When Docker starts, it creates a virtual interface named <code>docker0</code> on
the host machine.  It randomly chooses an address and subnet from the
private range defined by <a href="http://tools.ietf.org/html/rfc1918">RFC 1918</a>
that are not in use on the host machine, and assigns it to <code>docker0</code>.
Docker made the choice <code>172.17.42.1/16</code> when I started it a few minutes
ago, for example — a 16-bit netmask providing 65,534 addresses for the
host machine and its containers. The MAC address is generated using the
IP address allocated to the container to avoid ARP collisions, using a
range from <code>02:42:ac:11:00:00</code> to <code>02:42:ac:11:ff:ff</code>.</p>
<blockquote>
<p><strong>Note:</strong>
This document discusses advanced networking configuration
and options for Docker. In most cases you won't need this information.
If you're looking to get started with a simpler explanation of Docker
networking and an introduction to the concept of container linking see
the <a href="/userguide/dockerlinks/">Docker User Guide</a>.</p>
</blockquote>
<p>But <code>docker0</code> is no ordinary interface.  It is a virtual <em>Ethernet
bridge</em> that automatically forwards packets between any other network
interfaces that are attached to it.  This lets containers communicate
both with the host machine and with each other.  Every time Docker
creates a container, it creates a pair of “peer” interfaces that are
like opposite ends of a pipe — a packet sent on one will be received on
the other.  It gives one of the peers to the container to become its
<code>eth0</code> interface and keeps the other peer, with a unique name like
<code>vethAQI2QT</code>, out in the namespace of the host machine.  By binding
every <code>veth*</code> interface to the <code>docker0</code> bridge, Docker creates a
virtual subnet shared between the host machine and every Docker
container.</p>
<p>The remaining sections of this document explain all of the ways that you
can use Docker options and — in advanced cases — raw Linux networking
commands to tweak, supplement, or entirely replace Docker's default
networking configuration.</p>
<h2 id="quick-guide-to-the-options">Quick Guide to the Options</h2>
<p>Here is a quick list of the networking-related Docker command-line
options, in case it helps you find the section below that you are
looking for.</p>
<p>Some networking command-line options can only be supplied to the Docker
server when it starts up, and cannot be changed once it is running:</p>
<ul>
<li>
<p><code>-b BRIDGE</code> or <code>--bridge=BRIDGE</code> — see
    <a href="#bridge-building">Building your own bridge</a></p>
</li>
<li>
<p><code>--bip=CIDR</code> — see
    <a href="#docker0">Customizing docker0</a></p>
</li>
<li>
<p><code>--fixed-cidr</code> — see
    <a href="#docker0">Customizing docker0</a></p>
</li>
<li>
<p><code>--fixed-cidr-v6</code> — see
    <a href="#ipv6">IPv6</a></p>
</li>
<li>
<p><code>-H SOCKET...</code> or <code>--host=SOCKET...</code> —
    This might sound like it would affect container networking,
    but it actually faces in the other direction:
    it tells the Docker server over what channels
    it should be willing to receive commands
    like “run container” and “stop container.”</p>
</li>
<li>
<p><code>--icc=true|false</code> — see
    <a href="#between-containers">Communication between containers</a></p>
</li>
<li>
<p><code>--ip=IP_ADDRESS</code> — see
    <a href="#binding-ports">Binding container ports</a></p>
</li>
<li>
<p><code>--ipv6=true|false</code> — see
    <a href="#ipv6">IPv6</a></p>
</li>
<li>
<p><code>--ip-forward=true|false</code> — see
    <a href="#the-world">Communication between containers and the wider world</a></p>
</li>
<li>
<p><code>--iptables=true|false</code> — see
    <a href="#between-containers">Communication between containers</a></p>
</li>
<li>
<p><code>--mtu=BYTES</code> — see
    <a href="#docker0">Customizing docker0</a></p>
</li>
</ul>
<p>There are two networking options that can be supplied either at startup
or when <code>docker run</code> is invoked.  When provided at startup, set the
default value that <code>docker run</code> will later use if the options are not
specified:</p>
<ul>
<li>
<p><code>--dns=IP_ADDRESS...</code> — see
    <a href="#dns">Configuring DNS</a></p>
</li>
<li>
<p><code>--dns-search=DOMAIN...</code> — see
    <a href="#dns">Configuring DNS</a></p>
</li>
</ul>
<p>Finally, several networking options can only be provided when calling
<code>docker run</code> because they specify something specific to one container:</p>
<ul>
<li>
<p><code>-h HOSTNAME</code> or <code>--hostname=HOSTNAME</code> — see
    <a href="#dns">Configuring DNS</a> and
    <a href="#container-networking">How Docker networks a container</a></p>
</li>
<li>
<p><code>--link=CONTAINER_NAME_or_ID:ALIAS</code> — see
    <a href="#dns">Configuring DNS</a> and
    <a href="#between-containers">Communication between containers</a></p>
</li>
<li>
<p><code>--net=bridge|none|container:NAME_or_ID|host</code> — see
    <a href="#container-networking">How Docker networks a container</a></p>
</li>
<li>
<p><code>--mac-address=MACADDRESS...</code> — see
    <a href="#container-networking">How Docker networks a container</a></p>
</li>
<li>
<p><code>-p SPEC</code> or <code>--publish=SPEC</code> — see
    <a href="#binding-ports">Binding container ports</a></p>
</li>
<li>
<p><code>-P</code> or <code>--publish-all=true|false</code> — see
    <a href="#binding-ports">Binding container ports</a></p>
</li>
</ul>
<p>The following sections tackle all of the above topics in an order that
moves roughly from simplest to most complex.</p>
<h2 id="configuring-dns">Configuring DNS</h2>
<p><a name="dns"></a></p>
<p>How can Docker supply each container with a hostname and DNS
configuration, without having to build a custom image with the hostname
written inside?  Its trick is to overlay three crucial <code>/etc</code> files
inside the container with virtual files where it can write fresh
information.  You can see this by running <code>mount</code> inside a container:</p>
<pre class="prettyprint well"><code>$$ mount
...
/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...
/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...
/dev/disk/by-uuid/1fec...ebdf on /etc/resolv.conf type ext4 ...
...
</code></pre>
<p>This arrangement allows Docker to do clever things like keep
<code>resolv.conf</code> up to date across all containers when the host machine
receives new configuration over DHCP later.  The exact details of how
Docker maintains these files inside the container can change from one
Docker version to the next, so you should leave the files themselves
alone and use the following Docker options instead.</p>
<p>Four different options affect container domain name services.</p>
<ul>
<li>
<p><code>-h HOSTNAME</code> or <code>--hostname=HOSTNAME</code> — sets the hostname by which
    the container knows itself.  This is written into <code>/etc/hostname</code>,
    into <code>/etc/hosts</code> as the name of the container's host-facing IP
    address, and is the name that <code>/bin/bash</code> inside the container will
    display inside its prompt.  But the hostname is not easy to see from
    outside the container.  It will not appear in <code>docker ps</code> nor in the
    <code>/etc/hosts</code> file of any other container.</p>
</li>
<li>
<p><code>--link=CONTAINER_NAME_or_ID:ALIAS</code> — using this option as you <code>run</code> a
    container gives the new container's <code>/etc/hosts</code> an extra entry
    named <code>ALIAS</code> that points to the IP address of the container identified by
    <code>CONTAINER_NAME_or_ID</code>.  This lets processes inside the new container
    connect to the hostname <code>ALIAS</code> without having to know its IP.  The
    <code>--link=</code> option is discussed in more detail below, in the section
    <a href="#between-containers">Communication between containers</a>. Because
    Docker may assign a different IP address to the linked containers
    on restart, Docker updates the <code>ALIAS</code> entry in the <code>/etc/hosts</code> file
    of the recipient containers.</p>
</li>
<li>
<p><code>--dns=IP_ADDRESS...</code> — sets the IP addresses added as <code>server</code>
    lines to the container's <code>/etc/resolv.conf</code> file.  Processes in the
    container, when confronted with a hostname not in <code>/etc/hosts</code>, will
    connect to these IP addresses on port 53 looking for name resolution
    services.</p>
</li>
<li>
<p><code>--dns-search=DOMAIN...</code> — sets the domain names that are searched
    when a bare unqualified hostname is used inside of the container, by
    writing <code>search</code> lines into the container's <code>/etc/resolv.conf</code>.
    When a container process attempts to access <code>host</code> and the search
    domain <code>example.com</code> is set, for instance, the DNS logic will not
    only look up <code>host</code> but also <code>host.example.com</code>.
    Use <code>--dns-search=.</code> if you don't wish to set the search domain.</p>
</li>
</ul>
<p>Regarding DNS settings, in the absence of either the <code>--dns=IP_ADDRESS...</code>
or the <code>--dns-search=DOMAIN...</code> option, Docker makes each container's
<code>/etc/resolv.conf</code> look like the <code>/etc/resolv.conf</code> of the host machine (where
the <code>docker</code> daemon runs).  When creating the container's <code>/etc/resolv.conf</code>,
the daemon filters out all localhost IP address <code>nameserver</code> entries from
the host's original file.</p>
<p>Filtering is necessary because all localhost addresses on the host are
unreachable from the container's network.  After this filtering, if there 
are no more <code>nameserver</code> entries left in the container's <code>/etc/resolv.conf</code>
file, the daemon adds public Google DNS nameservers
(8.8.8.8 and 8.8.4.4) to the container's DNS configuration.  If IPv6 is
enabled on the daemon, the public IPv6 Google DNS nameservers will also
be added (2001:4860:4860::8888 and 2001:4860:4860::8844).</p>
<blockquote>
<p><strong>Note</strong>:
If you need access to a host's localhost resolver, you must modify your
DNS service on the host to listen on a non-localhost address that is
reachable from within the container.</p>
</blockquote>
<p>You might wonder what happens when the host machine's
<code>/etc/resolv.conf</code> file changes.  The <code>docker</code> daemon has a file change
notifier active which will watch for changes to the host DNS configuration.</p>
<blockquote>
<p><strong>Note</strong>:
The file change notifier relies on the Linux kernel's inotify feature.
Because this feature is currently incompatible with the overlay filesystem 
driver, a Docker daemon using "overlay" will not be able to take advantage
of the <code>/etc/resolv.conf</code> auto-update feature.</p>
</blockquote>
<p>When the host file changes, all stopped containers which have a matching
<code>resolv.conf</code> to the host will be updated immediately to this newest host
configuration.  Containers which are running when the host configuration
changes will need to stop and start to pick up the host changes due to lack
of a facility to ensure atomic writes of the <code>resolv.conf</code> file while the
container is running. If the container's <code>resolv.conf</code> has been edited since
it was started with the default configuration, no replacement will be
attempted as it would overwrite the changes performed by the container.
If the options (<code>--dns</code> or <code>--dns-search</code>) have been used to modify the 
default host configuration, then the replacement with an updated host's
<code>/etc/resolv.conf</code> will not happen as well.</p>
<blockquote>
<p><strong>Note</strong>:
For containers which were created prior to the implementation of
the <code>/etc/resolv.conf</code> update feature in Docker 1.5.0: those
containers will <strong>not</strong> receive updates when the host <code>resolv.conf</code>
file changes. Only containers created with Docker 1.5.0 and above
will utilize this auto-update feature.</p>
</blockquote>
<h2 id="communication-between-containers-and-the-wider-world">Communication between containers and the wider world</h2>
<p><a name="the-world"></a></p>
<p>Whether a container can talk to the world is governed by two factors.</p>
<ol>
<li>
<p>Is the host machine willing to forward IP packets?  This is governed
    by the <code>ip_forward</code> system parameter.  Packets can only pass between
    containers if this parameter is <code>1</code>.  Usually you will simply leave
    the Docker server at its default setting <code>--ip-forward=true</code> and
    Docker will go set <code>ip_forward</code> to <code>1</code> for you when the server
    starts up. To check the setting or turn it on manually:</p>
<pre class="prettyprint well"><code>$ sysctl net.ipv4.conf.all.forwarding
net.ipv4.conf.all.forwarding = 0
$ sysctl net.ipv4.conf.all.forwarding=1
$ sysctl net.ipv4.conf.all.forwarding
net.ipv4.conf.all.forwarding = 1
</code></pre>
<p>Many using Docker will want <code>ip_forward</code> to be on, to at
least make communication <em>possible</em> between containers and
the wider world.</p>
<p>May also be needed for inter-container communication if you are
in a multiple bridge setup.</p>
</li>
<li>
<p>Do your <code>iptables</code> allow this particular connection? Docker will
    never make changes to your system <code>iptables</code> rules if you set
    <code>--iptables=false</code> when the daemon starts.  Otherwise the Docker
    server will append forwarding rules to the <code>DOCKER</code> filter chain.</p>
</li>
</ol>
<p>Docker will not delete or modify any pre-existing rules from the <code>DOCKER</code>
filter chain. This allows the user to create in advance any rules required
to further restrict access to the containers.</p>
<p>Docker's forward rules permit all external source IPs by default. To allow
only a specific IP or network to access the containers, insert a negated
rule at the top of the <code>DOCKER</code> filter chain. For example, to restrict
external access such that <em>only</em> source IP 8.8.8.8 can access the
containers, the following rule could be added:</p>
<pre class="prettyprint well"><code>$ iptables -I DOCKER -i ext_if ! -s 8.8.8.8 -j DROP
</code></pre>
<h2 id="communication-between-containers">Communication between containers</h2>
<p><a name="between-containers"></a></p>
<p>Whether two containers can communicate is governed, at the operating
system level, by two factors.</p>
<ol>
<li>
<p>Does the network topology even connect the containers' network
    interfaces?  By default Docker will attach all containers to a
    single <code>docker0</code> bridge, providing a path for packets to travel
    between them.  See the later sections of this document for other
    possible topologies.</p>
</li>
<li>
<p>Do your <code>iptables</code> allow this particular connection? Docker will never
    make changes to your system <code>iptables</code> rules if you set
    <code>--iptables=false</code> when the daemon starts.  Otherwise the Docker server
    will add a default rule to the <code>FORWARD</code> chain with a blanket <code>ACCEPT</code>
    policy if you retain the default <code>--icc=true</code>, or else will set the
    policy to <code>DROP</code> if <code>--icc=false</code>.</p>
</li>
</ol>
<p>It is a strategic question whether to leave <code>--icc=true</code> or change it to
<code>--icc=false</code> (on Ubuntu, by editing the <code>DOCKER_OPTS</code> variable in
<code>/etc/default/docker</code> and restarting the Docker server) so that
<code>iptables</code> will protect other containers — and the main host — from
having arbitrary ports probed or accessed by a container that gets
compromised.</p>
<p>If you choose the most secure setting of <code>--icc=false</code>, then how can
containers communicate in those cases where you <em>want</em> them to provide
each other services?</p>
<p>The answer is the <code>--link=CONTAINER_NAME_or_ID:ALIAS</code> option, which was
mentioned in the previous section because of its effect upon name
services.  If the Docker daemon is running with both <code>--icc=false</code> and
<code>--iptables=true</code> then, when it sees <code>docker run</code> invoked with the
<code>--link=</code> option, the Docker server will insert a pair of <code>iptables</code>
<code>ACCEPT</code> rules so that the new container can connect to the ports
exposed by the other container — the ports that it mentioned in the
<code>EXPOSE</code> lines of its <code>Dockerfile</code>.  Docker has more documentation on
this subject — see the <a href="/userguide/dockerlinks">linking Docker containers</a>
page for further details.</p>
<blockquote>
<p><strong>Note</strong>:
The value <code>CONTAINER_NAME</code> in <code>--link=</code> must either be an
auto-assigned Docker name like <code>stupefied_pare</code> or else the name you
assigned with <code>--name=</code> when you ran <code>docker run</code>.  It cannot be a
hostname, which Docker will not recognize in the context of the
<code>--link=</code> option.</p>
</blockquote>
<p>You can run the <code>iptables</code> command on your Docker host to see whether
the <code>FORWARD</code> chain has a default policy of <code>ACCEPT</code> or <code>DROP</code>:</p>
<pre class="prettyprint well"><code># When --icc=false, you should see a DROP rule:

$ sudo iptables -L -n
...
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
DOCKER     all  --  0.0.0.0/0            0.0.0.0/0
DROP       all  --  0.0.0.0/0            0.0.0.0/0
...

# When a --link= has been created under --icc=false,
# you should see port-specific ACCEPT rules overriding
# the subsequent DROP policy for all other packets:

$ sudo iptables -L -n
...
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
DOCKER     all  --  0.0.0.0/0            0.0.0.0/0
DROP       all  --  0.0.0.0/0            0.0.0.0/0

Chain DOCKER (1 references)
target     prot opt source               destination
ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80
ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80
</code></pre>
<blockquote>
<p><strong>Note</strong>:
Docker is careful that its host-wide <code>iptables</code> rules fully expose
containers to each other's raw IP addresses, so connections from one
container to another should always appear to be originating from the
first container's own IP address.</p>
</blockquote>
<h2 id="binding-container-ports-to-the-host">Binding container ports to the host</h2>
<p><a name="binding-ports"></a></p>
<p>By default Docker containers can make connections to the outside world,
but the outside world cannot connect to containers.  Each outgoing
connection will appear to originate from one of the host machine's own
IP addresses thanks to an <code>iptables</code> masquerading rule on the host
machine that the Docker server creates when it starts:</p>
<pre class="prettyprint well"><code># You can see that the Docker server creates a
# masquerade rule that let containers connect
# to IP addresses in the outside world:

$ sudo iptables -t nat -L -n
...
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16
...
</code></pre>
<p>But if you want containers to accept incoming connections, you will need
to provide special options when invoking <code>docker run</code>.  These options
are covered in more detail in the <a href="/userguide/dockerlinks">Docker User Guide</a>
page.  There are two approaches.</p>
<p>First, you can supply <code>-P</code> or <code>--publish-all=true|false</code> to <code>docker run</code> which
is a blanket operation that identifies every port with an <code>EXPOSE</code> line in the
image's <code>Dockerfile</code> or <code>--expose &lt;port&gt;</code> commandline flag and maps it to a
host port somewhere within an <em>ephemeral port range</em>. The <code>docker port</code> command
then needs to be used to inspect created mapping. The <em>ephemeral port range</em> is
configured by <code>/proc/sys/net/ipv4/ip_local_port_range</code> kernel parameter,
typically ranging from 32768 to 61000.</p>
<p>Mapping can be specified explicitly using <code>-p SPEC</code> or <code>--publish=SPEC</code> option.
It allows you to particularize which port on docker server - which can be any
port at all, not just one within the <em>ephemeral port range</em> — you want mapped
to which port in the container.</p>
<p>Either way, you should be able to peek at what Docker has accomplished
in your network stack by examining your NAT tables.</p>
<pre class="prettyprint well"><code># What your NAT rules might look like when Docker
# is finished setting up a -P forward:

$ iptables -t nat -L -n
...
Chain DOCKER (2 references)
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80

# What your NAT rules might look like when Docker
# is finished setting up a -p 80:80 forward:

Chain DOCKER (2 references)
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80
</code></pre>
<p>You can see that Docker has exposed these container ports on <code>0.0.0.0</code>,
the wildcard IP address that will match any possible incoming port on
the host machine.  If you want to be more restrictive and only allow
container services to be contacted through a specific external interface
on the host machine, you have two choices.  When you invoke <code>docker run</code>
you can use either <code>-p IP:host_port:container_port</code> or <code>-p IP::port</code> to
specify the external interface for one particular binding.</p>
<p>Or if you always want Docker port forwards to bind to one specific IP
address, you can edit your system-wide Docker server settings (on
Ubuntu, by editing <code>DOCKER_OPTS</code> in <code>/etc/default/docker</code>) and add the
option <code>--ip=IP_ADDRESS</code>.  Remember to restart your Docker server after
editing this setting.</p>
<p>Again, this topic is covered without all of these low-level networking
details in the <a href="/userguide/dockerlinks/">Docker User Guide</a> document if you
would like to use that as your port redirection reference instead.</p>
<h2 id="ipv6">IPv6</h2>
<p><a name="ipv6"></a></p>
<p>As we are <a href="http://en.wikipedia.org/wiki/IPv4_address_exhaustion">running out of IPv4 addresses</a>
the IETF has standardized an IPv4 successor, <a href="http://en.wikipedia.org/wiki/IPv6">Internet Protocol Version 6</a>
, in <a href="https://www.ietf.org/rfc/rfc2460.txt">RFC 2460</a>. Both protocols, IPv4 and
IPv6, reside on layer 3 of the <a href="http://en.wikipedia.org/wiki/OSI_model">OSI model</a>.</p>
<h3 id="ipv6-with-docker">IPv6 with Docker</h3>
<p>By default, the Docker server configures the container network for IPv4 only.
You can enable IPv4/IPv6 dualstack support by running the Docker daemon with the
<code>--ipv6</code> flag. Docker will set up the bridge <code>docker0</code> with the IPv6
<a href="http://en.wikipedia.org/wiki/Link-local_address">link-local address</a> <code>fe80::1</code>.</p>
<p>By default, containers that are created will only get a link-local IPv6 address.
To assign globally routable IPv6 addresses to your containers you have to
specify an IPv6 subnet to pick the addresses from. Set the IPv6 subnet via the
<code>--fixed-cidr-v6</code> parameter when starting Docker daemon:</p>
<pre class="prettyprint well"><code>docker -d --ipv6 --fixed-cidr-v6="2001:db8:1::/64"
</code></pre>
<p>The subnet for Docker containers should at least have a size of <code>/80</code>. This way
an IPv6 address can end with the container's MAC address and you prevent NDP
neighbor cache invalidation issues in the Docker layer.</p>
<p>With the <code>--fixed-cidr-v6</code> parameter set Docker will add a new route to the
routing table. Further IPv6 routing will be enabled (you may prevent this by
starting Docker daemon with <code>--ip-forward=false</code>):</p>
<pre class="prettyprint well"><code>$ ip -6 route add 2001:db8:1::/64 dev docker0
$ sysctl net.ipv6.conf.default.forwarding=1
$ sysctl net.ipv6.conf.all.forwarding=1
</code></pre>
<p>All traffic to the subnet <code>2001:db8:1::/64</code> will now be routed
via the <code>docker0</code> interface.</p>
<p>Be aware that IPv6 forwarding may interfere with your existing IPv6
configuration: If you are using Router Advertisements to get IPv6 settings for
your host's interfaces you should set <code>accept_ra</code> to <code>2</code>. Otherwise IPv6
enabled forwarding will result in rejecting Router Advertisements. E.g., if you
want to configure <code>eth0</code> via Router Advertisements you should set:</p>
<pre class="prettyprint well"><code>$ sysctl net.ipv6.conf.eth0.accept_ra=2
</code></pre>
<p><img alt="" src="/article-img/ipv6_basic_host_config.svg" /></p>
<p>Every new container will get an IPv6 address from the defined subnet. Further
a default route will be added via the gateway <code>fe80::1</code> on <code>eth0</code>:</p>
<pre class="prettyprint well"><code>docker run -it ubuntu bash -c "ip -6 addr show dev eth0; ip -6 route show"

15: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500
   inet6 2001:db8:1:0:0:242:ac11:3/64 scope global
      valid_lft forever preferred_lft forever
   inet6 fe80::42:acff:fe11:3/64 scope link
      valid_lft forever preferred_lft forever

2001:db8:1::/64 dev eth0  proto kernel  metric 256
fe80::/64 dev eth0  proto kernel  metric 256
default via fe80::1 dev eth0  metric 1024
</code></pre>
<p>In this example the Docker container is assigned a link-local address with the
network suffix <code>/64</code> (here: <code>fe80::42:acff:fe11:3/64</code>) and a globally routable
IPv6 address (here: <code>2001:db8:1:0:0:242:ac11:3/64</code>). The container will create
connections to addresses outside of the <code>2001:db8:1::/64</code> network via the
link-local gateway at <code>fe80::1</code> on <code>eth0</code>.</p>
<p>Often servers or virtual machines get a <code>/64</code> IPv6 subnet assigned (e.g.
<code>2001:db8:23:42::/64</code>). In this case you can split it up further and provide
Docker a <code>/80</code> subnet while using a separate <code>/80</code> subnet for other
applications on the host:</p>
<p><img alt="" src="/article-img/ipv6_slash64_subnet_config.svg" /></p>
<p>In this setup the subnet <code>2001:db8:23:42::/80</code> with a range from <code>2001:db8:23:42:0:0:0:0</code>
to <code>2001:db8:23:42:0:ffff:ffff:ffff</code> is attached to <code>eth0</code>, with the host listening
at <code>2001:db8:23:42::1</code>. The subnet <code>2001:db8:23:42:1::/80</code> with an address range from
<code>2001:db8:23:42:1:0:0:0</code> to <code>2001:db8:23:42:1:ffff:ffff:ffff</code> is attached to
<code>docker0</code> and will be used by containers.</p>
<h4 id="using-ndp-proxying">Using NDP proxying</h4>
<p>If your Docker host is only part of an IPv6 subnet but has not got an IPv6
subnet assigned you can use NDP proxying to connect your containers via IPv6 to
the internet.
For example your host has the IPv6 address <code>2001:db8::c001</code>, is part of the
subnet <code>2001:db8::/64</code> and your IaaS provider allows you to configure the IPv6
addresses <code>2001:db8::c000</code> to <code>2001:db8::c00f</code>:</p>
<pre class="prettyprint well"><code>$ ip -6 addr show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qlen 1000
    inet6 2001:db8::c001/64 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::601:3fff:fea1:9c01/64 scope link
       valid_lft forever preferred_lft forever
</code></pre>
<p>Let's split up the configurable address range into two subnets
<code>2001:db8::c000/125</code> and <code>2001:db8::c008/125</code>. The first one can be used by the
host itself, the latter by Docker:</p>
<pre class="prettyprint well"><code>docker -d --ipv6 --fixed-cidr-v6 2001:db8::c008/125
</code></pre>
<p>You notice the Docker subnet is within the subnet managed by your router that
is connected to <code>eth0</code>. This means all devices (containers) with the addresses
from the Docker subnet are expected to be found within the router subnet.
Therefore the router thinks it can talk to these containers directly.</p>
<p><img alt="" src="/article-img/ipv6_ndp_proxying.svg" /></p>
<p>As soon as the router wants to send an IPv6 packet to the first container it
will transmit a neighbor solicitation request, asking, who has
<code>2001:db8::c009</code>? But it will get no answer because noone on this subnet has
this address. The container with this address is hidden behind the Docker host.
The Docker host has to listen to neighbor solication requests for the container
address and send a response that itself is the device that is responsible for
the address. This is done by a Kernel feature called <code>NDP Proxy</code>. You can
enable it by executing</p>
<pre class="prettyprint well"><code>$ sysctl net.ipv6.conf.eth0.proxy_ndp=1
</code></pre>
<p>Now you can add the container's IPv6 address to the NDP proxy table:</p>
<pre class="prettyprint well"><code>$ ip -6 neigh add proxy 2001:db8::c009 dev eth0
</code></pre>
<p>This command tells the Kernel to answer to incoming neighbor solicitation requests
regarding the IPv6 address <code>2001:db8::c009</code> on the device <code>eth0</code>. As a
consequence of this all traffic to this IPv6 address will go into the Docker
host and it will forward it according to its routing table via the <code>docker0</code>
device to the container network:</p>
<pre class="prettyprint well"><code>$ ip -6 route show
2001:db8::c008/125 dev docker0  metric 1
2001:db8::/64 dev eth0  proto kernel  metric 256
</code></pre>
<p>You have to execute the <code>ip -6 neigh add proxy ...</code> command for every IPv6
address in your Docker subnet. Unfortunately there is no functionality for
adding a whole subnet by executing one command. An alternative approach would be to
use an NDP proxy daemon such as <a href="https://github.com/DanielAdolfsson/ndppd">ndppd</a>.</p>
<h3 id="docker-ipv6-cluster">Docker IPv6 Cluster</h3>
<h4 id="switched-network-environment">Switched Network Environment</h4>
<p>Using routable IPv6 addresses allows you to realize communication between
containers on different hosts. Let's have a look at a simple Docker IPv6 cluster
example:</p>
<p><img alt="" src="/article-img/ipv6_switched_network_example.svg" /></p>
<p>The Docker hosts are in the <code>2001:db8:0::/64</code> subnet. Host1 is configured
to provide addresses from the <code>2001:db8:1::/64</code> subnet to its containers. It
has three routes configured:</p>
<ul>
<li>Route all traffic to <code>2001:db8:0::/64</code> via <code>eth0</code></li>
<li>Route all traffic to <code>2001:db8:1::/64</code> via <code>docker0</code></li>
<li>Route all traffic to <code>2001:db8:2::/64</code> via Host2 with IP <code>2001:db8::2</code></li>
</ul>
<p>Host1 also acts as a router on OSI layer 3. When one of the network clients
tries to contact a target that is specified in Host1's routing table Host1 will
forward the traffic accordingly. It acts as a router for all networks it knows:
<code>2001:db8::/64</code>, <code>2001:db8:1::/64</code> and <code>2001:db8:2::/64</code>.</p>
<p>On Host2 we have nearly the same configuration. Host2's containers will get
IPv6 addresses from <code>2001:db8:2::/64</code>. Host2 has three routes configured:</p>
<ul>
<li>Route all traffic to <code>2001:db8:0::/64</code> via <code>eth0</code></li>
<li>Route all traffic to <code>2001:db8:2::/64</code> via <code>docker0</code></li>
<li>Route all traffic to <code>2001:db8:1::/64</code> via Host1 with IP <code>2001:db8:0::1</code></li>
</ul>
<p>The difference to Host1 is that the network <code>2001:db8:2::/64</code> is directly
attached to the host via its <code>docker0</code> interface whereas it reaches
<code>2001:db8:1::/64</code> via Host1's IPv6 address <code>2001:db8::1</code>.</p>
<p>This way every container is able to contact every other container. The
containers <code>Container1-*</code> share the same subnet and contact each other directly.
The traffic between <code>Container1-*</code> and <code>Container2-*</code> will be routed via Host1
and Host2 because those containers do not share the same subnet.</p>
<p>In a switched environment every host has to know all routes to every subnet. You
always have to update the hosts' routing tables once you add or remove a host
to the cluster.</p>
<p>Every configuration in the diagram that is shown below the dashed line is
handled by Docker: The <code>docker0</code> bridge IP address configuration, the route to
the Docker subnet on the host, the container IP addresses and the routes on the
containers. The configuration above the line is up to the user and can be
adapted to the individual environment.</p>
<h4 id="routed-network-environment">Routed Network Environment</h4>
<p>In a routed network environment you replace the level 2 switch with a level 3
router. Now the hosts just have to know their default gateway (the router) and
the route to their own containers (managed by Docker). The router holds all
routing information about the Docker subnets. When you add or remove a host to
this environment you just have to update the routing table in the router - not
on every host.</p>
<p><img alt="" src="/article-img/ipv6_routed_network_example.svg" /></p>
<p>In this scenario containers of the same host can communicate directly with each
other. The traffic between containers on different hosts will be routed via
their hosts and the router. For example packet from <code>Container1-1</code> to 
<code>Container2-1</code> will be routed through <code>Host1</code>, <code>Router</code> and <code>Host2</code> until it
arrives at <code>Container2-1</code>.</p>
<p>To keep the IPv6 addresses short in this example a <code>/48</code> network is assigned to
every host. The hosts use a <code>/64</code> subnet of this for its own services and one
for Docker. When adding a third host you would add a route for the subnet
<code>2001:db8:3::/48</code> in the router and configure Docker on Host3 with
<code>--fixed-cidr-v6=2001:db8:3:1::/64</code>.</p>
<p>Remember the subnet for Docker containers should at least have a size of <code>/80</code>.
This way an IPv6 address can end with the container's MAC address and you
prevent NDP neighbor cache invalidation issues in the Docker layer. So if you
have a <code>/64</code> for your whole environment use <code>/68</code> subnets for the hosts and
<code>/80</code> for the containers. This way you can use 4096 hosts with 16 <code>/80</code> subnets
each.</p>
<p>Every configuration in the diagram that is visualized below the dashed line is
handled by Docker: The <code>docker0</code> bridge IP address configuration, the route to
the Docker subnet on the host, the container IP addresses and the routes on the
containers. The configuration above the line is up to the user and can be
adapted to the individual environment.</p>
<h2 id="customizing-docker0">Customizing docker0</h2>
<p><a name="docker0"></a></p>
<p>By default, the Docker server creates and configures the host system's
<code>docker0</code> interface as an <em>Ethernet bridge</em> inside the Linux kernel that
can pass packets back and forth between other physical or virtual
network interfaces so that they behave as a single Ethernet network.</p>
<p>Docker configures <code>docker0</code> with an IP address, netmask and IP
allocation range. The host machine can both receive and send packets to
containers connected to the bridge, and gives it an MTU — the <em>maximum
transmission unit</em> or largest packet length that the interface will
allow — of either 1,500 bytes or else a more specific value copied from
the Docker host's interface that supports its default route.  These
options are configurable at server startup:</p>
<ul>
<li>
<p><code>--bip=CIDR</code> — supply a specific IP address and netmask for the
    <code>docker0</code> bridge, using standard CIDR notation like
    <code>192.168.1.5/24</code>.</p>
</li>
<li>
<p><code>--fixed-cidr=CIDR</code> — restrict the IP range from the <code>docker0</code> subnet,
    using the standard CIDR notation like <code>172.167.1.0/28</code>. This range must
    be and IPv4 range for fixed IPs (ex: 10.20.0.0/16) and must be a subset
    of the bridge IP range (<code>docker0</code> or set using <code>--bridge</code>). For example
    with <code>--fixed-cidr=192.168.1.0/25</code>, IPs for your containers will be chosen
    from the first half of <code>192.168.1.0/24</code> subnet.</p>
</li>
<li>
<p><code>--mtu=BYTES</code> — override the maximum packet length on <code>docker0</code>.</p>
</li>
</ul>
<p>On Ubuntu you would add these to the <code>DOCKER_OPTS</code> setting in
<code>/etc/default/docker</code> on your Docker host and restarting the Docker
service.</p>
<p>Once you have one or more containers up and running, you can confirm
that Docker has properly connected them to the <code>docker0</code> bridge by
running the <code>brctl</code> command on the host machine and looking at the
<code>interfaces</code> column of the output.  Here is a host with two different
containers connected:</p>
<pre class="prettyprint well"><code># Display bridge info

$ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.3a1d7362b4ee       no              veth65f9
                                                        vethdda6
</code></pre>
<p>If the <code>brctl</code> command is not installed on your Docker host, then on
Ubuntu you should be able to run <code>sudo apt-get install bridge-utils</code> to
install it.</p>
<p>Finally, the <code>docker0</code> Ethernet bridge settings are used every time you
create a new container.  Docker selects a free IP address from the range
available on the bridge each time you <code>docker run</code> a new container, and
configures the container's <code>eth0</code> interface with that IP address and the
bridge's netmask.  The Docker host's own IP address on the bridge is
used as the default gateway by which each container reaches the rest of
the Internet.</p>
<pre class="prettyprint well"><code># The network, as seen from a container

$ sudo docker run -i -t --rm base /bin/bash

$$ ip addr show eth0
24: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.3/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::306f:e0ff:fe35:5791/64 scope link
       valid_lft forever preferred_lft forever

$$ ip route
default via 172.17.42.1 dev eth0
172.17.0.0/16 dev eth0  proto kernel  scope link  src 172.17.0.3

$$ exit
</code></pre>
<p>Remember that the Docker host will not be willing to forward container
packets out on to the Internet unless its <code>ip_forward</code> system setting is
<code>1</code> — see the section above on <a href="#between-containers">Communication between
containers</a> for details.</p>
<h2 id="building-your-own-bridge">Building your own bridge</h2>
<p><a name="bridge-building"></a></p>
<p>If you want to take Docker out of the business of creating its own
Ethernet bridge entirely, you can set up your own bridge before starting
Docker and use <code>-b BRIDGE</code> or <code>--bridge=BRIDGE</code> to tell Docker to use
your bridge instead.  If you already have Docker up and running with its
old <code>docker0</code> still configured, you will probably want to begin by
stopping the service and removing the interface:</p>
<pre class="prettyprint well"><code># Stopping Docker and removing docker0

$ sudo service docker stop
$ sudo ip link set dev docker0 down
$ sudo brctl delbr docker0
$ sudo iptables -t nat -F POSTROUTING
</code></pre>
<p>Then, before starting the Docker service, create your own bridge and
give it whatever configuration you want.  Here we will create a simple
enough bridge that we really could just have used the options in the
previous section to customize <code>docker0</code>, but it will be enough to
illustrate the technique.</p>
<pre class="prettyprint well"><code># Create our own bridge

$ sudo brctl addbr bridge0
$ sudo ip addr add 192.168.5.1/24 dev bridge0
$ sudo ip link set dev bridge0 up

# Confirming that our bridge is up and running

$ ip addr show bridge0
4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default
    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff
    inet 192.168.5.1/24 scope global bridge0
       valid_lft forever preferred_lft forever

# Tell Docker about it and restart (on Ubuntu)

$ echo 'DOCKER_OPTS="-b=bridge0"' &gt;&gt; /etc/default/docker
$ sudo service docker start

# Confirming new outgoing NAT masquerade is set up

$ sudo iptables -t nat -L -n
...
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
MASQUERADE  all  --  192.168.5.0/24      0.0.0.0/0
</code></pre>
<p>The result should be that the Docker server starts successfully and is
now prepared to bind containers to the new bridge.  After pausing to
verify the bridge's configuration, try creating a container — you will
see that its IP address is in your new IP address range, which Docker
will have auto-detected.</p>
<p>Just as we learned in the previous section, you can use the <code>brctl show</code>
command to see Docker add and remove interfaces from the bridge as you
start and stop containers, and can run <code>ip addr</code> and <code>ip route</code> inside a
container to see that it has been given an address in the bridge's IP
address range and has been told to use the Docker host's IP address on
the bridge as its default gateway to the rest of the Internet.</p>
<h2 id="how-docker-networks-a-container">How Docker networks a container</h2>
<p><a name="container-networking"></a></p>
<p>While Docker is under active development and continues to tweak and
improve its network configuration logic, the shell commands in this
section are rough equivalents to the steps that Docker takes when
configuring networking for each new container.</p>
<p>Let's review a few basics.</p>
<p>To communicate using the Internet Protocol (IP), a machine needs access
to at least one network interface at which packets can be sent and
received, and a routing table that defines the range of IP addresses
reachable through that interface.  Network interfaces do not have to be
physical devices.  In fact, the <code>lo</code> loopback interface available on
every Linux machine (and inside each Docker container) is entirely
virtual — the Linux kernel simply copies loopback packets directly from
the sender's memory into the receiver's memory.</p>
<p>Docker uses special virtual interfaces to let containers communicate
with the host machine — pairs of virtual interfaces called “peers” that
are linked inside of the host machine's kernel so that packets can
travel between them.  They are simple to create, as we will see in a
moment.</p>
<p>The steps with which Docker configures a container are:</p>
<ol>
<li>
<p>Create a pair of peer virtual interfaces.</p>
</li>
<li>
<p>Give one of them a unique name like <code>veth65f9</code>, keep it inside of
    the main Docker host, and bind it to <code>docker0</code> or whatever bridge
    Docker is supposed to be using.</p>
</li>
<li>
<p>Toss the other interface over the wall into the new container (which
    will already have been provided with an <code>lo</code> interface) and rename
    it to the much prettier name <code>eth0</code> since, inside of the container's
    separate and unique network interface namespace, there are no
    physical interfaces with which this name could collide.</p>
</li>
<li>
<p>Set the interface's MAC address according to the <code>--mac-address</code>
    parameter or generate a random one.</p>
</li>
<li>
<p>Give the container's <code>eth0</code> a new IP address from within the
    bridge's range of network addresses, and set its default route to
    the IP address that the Docker host owns on the bridge. The MAC
    address is generated from the IP address unless otherwise specified.
    This prevents ARP cache invalidation problems, when a new container
    comes up with an IP used in the past by another container with another
    MAC.</p>
</li>
</ol>
<p>With these steps complete, the container now possesses an <code>eth0</code>
(virtual) network card and will find itself able to communicate with
other containers and the rest of the Internet.</p>
<p>You can opt out of the above process for a particular container by
giving the <code>--net=</code> option to <code>docker run</code>, which takes four possible
values.</p>
<ul>
<li>
<p><code>--net=bridge</code> — The default action, that connects the container to
    the Docker bridge as described above.</p>
</li>
<li>
<p><code>--net=host</code> — Tells Docker to skip placing the container inside of
    a separate network stack.  In essence, this choice tells Docker to
    <strong>not containerize the container's networking</strong>!  While container
    processes will still be confined to their own filesystem and process
    list and resource limits, a quick <code>ip addr</code> command will show you
    that, network-wise, they live “outside” in the main Docker host and
    have full access to its network interfaces.  Note that this does
    <strong>not</strong> let the container reconfigure the host network stack — that
    would require <code>--privileged=true</code> — but it does let container
    processes open low-numbered ports like any other root process.
    It also allows the container to access local network services
    like D-bus.  This can lead to processes in the container being
    able to do unexpected things like
    <a href="https://github.com/docker/docker/issues/6401">restart your computer</a>.
    You should use this option with caution.</p>
</li>
<li>
<p><code>--net=container:NAME_or_ID</code> — Tells Docker to put this container's
    processes inside of the network stack that has already been created
    inside of another container.  The new container's processes will be
    confined to their own filesystem and process list and resource
    limits, but will share the same IP address and port numbers as the
    first container, and processes on the two containers will be able to
    connect to each other over the loopback interface.</p>
</li>
<li>
<p><code>--net=none</code> — Tells Docker to put the container inside of its own
    network stack but not to take any steps to configure its network,
    leaving you free to build any of the custom configurations explored
    in the last few sections of this document.</p>
</li>
</ul>
<p>To get an idea of the steps that are necessary if you use <code>--net=none</code>
as described in that last bullet point, here are the commands that you
would run to reach roughly the same configuration as if you had let
Docker do all of the configuration:</p>
<pre class="prettyprint well"><code># At one shell, start a container and
# leave its shell idle and running

$ sudo docker run -i -t --rm --net=none base /bin/bash
root@63f36fc01b5f:/#

# At another shell, learn the container process ID
# and create its namespace entry in /var/run/netns/
# for the "ip netns" command we will be using below

$ sudo docker inspect -f '{{.State.Pid}}' 63f36fc01b5f
2778
$ pid=2778
$ sudo mkdir -p /var/run/netns
$ sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid

# Check the bridge's IP address and netmask

$ ip addr show docker0
21: docker0: ...
inet 172.17.42.1/16 scope global docker0
...

# Create a pair of "peer" interfaces A and B,
# bind the A end to the bridge, and bring it up

$ sudo ip link add A type veth peer name B
$ sudo brctl addif docker0 A
$ sudo ip link set A up

# Place B inside the container's network namespace,
# rename to eth0, and activate it with a free IP

$ sudo ip link set B netns $pid
$ sudo ip netns exec $pid ip link set dev B name eth0
$ sudo ip netns exec $pid ip link set eth0 address 12:34:56:78:9a:bc
$ sudo ip netns exec $pid ip link set eth0 up
$ sudo ip netns exec $pid ip addr add 172.17.42.99/16 dev eth0
$ sudo ip netns exec $pid ip route add default via 172.17.42.1
</code></pre>
<p>At this point your container should be able to perform networking
operations as usual.</p>
<p>When you finally exit the shell and Docker cleans up the container, the
network namespace is destroyed along with our virtual <code>eth0</code> — whose
destruction in turn destroys interface <code>A</code> out in the Docker host and
automatically un-registers it from the <code>docker0</code> bridge.  So everything
gets cleaned up without our having to run any extra commands!  Well,
almost everything:</p>
<pre class="prettyprint well"><code># Clean up dangling symlinks in /var/run/netns

find -L /var/run/netns -type l -delete
</code></pre>
<p>Also note that while the script above used modern <code>ip</code> command instead
of old deprecated wrappers like <code>ipconfig</code> and <code>route</code>, these older
commands would also have worked inside of our container.  The <code>ip addr</code>
command can be typed as <code>ip a</code> if you are in a hurry.</p>
<p>Finally, note the importance of the <code>ip netns exec</code> command, which let
us reach inside and configure a network namespace as root.  The same
commands would not have worked if run inside of the container, because
part of safe containerization is that Docker strips container processes
of the right to configure their own networks.  Using <code>ip netns exec</code> is
what let us finish up the configuration without having to take the
dangerous step of running the container itself with <code>--privileged=true</code>.</p>
<h2 id="tools-and-examples">Tools and Examples</h2>
<p>Before diving into the following sections on custom network topologies,
you might be interested in glancing at a few external tools or examples
of the same kinds of configuration.  Here are two:</p>
<ul>
<li>
<p>Jérôme Petazzoni has created a <code>pipework</code> shell script to help you
    connect together containers in arbitrarily complex scenarios:
    <a href="https://github.com/jpetazzo/pipework">https://github.com/jpetazzo/pipework</a></p>
</li>
<li>
<p>Brandon Rhodes has created a whole network topology of Docker
    containers for the next edition of Foundations of Python Network
    Programming that includes routing, NAT'd firewalls, and servers that
    offer HTTP, SMTP, POP, IMAP, Telnet, SSH, and FTP:
    <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground">https://github.com/brandon-rhodes/fopnp/tree/m/playground</a></p>
</li>
</ul>
<p>Both tools use networking commands very much like the ones you saw in
the previous section, and will see in the following sections.</p>
<h2 id="building-a-point-to-point-connection">Building a point-to-point connection</h2>
<p><a name="point-to-point"></a></p>
<p>By default, Docker attaches all containers to the virtual subnet
implemented by <code>docker0</code>.  You can create containers that are each
connected to some different virtual subnet by creating your own bridge
as shown in <a href="#bridge-building">Building your own bridge</a>, starting each
container with <code>docker run --net=none</code>, and then attaching the
containers to your bridge with the shell commands shown in <a href="#container-networking">How Docker
networks a container</a>.</p>
<p>But sometimes you want two particular containers to be able to
communicate directly without the added complexity of both being bound to
a host-wide Ethernet bridge.</p>
<p>The solution is simple: when you create your pair of peer interfaces,
simply throw <em>both</em> of them into containers, and configure them as
classic point-to-point links.  The two containers will then be able to
communicate directly (provided you manage to tell each container the
other's IP address, of course).  You might adjust the instructions of
the previous section to go something like this:</p>
<pre class="prettyprint well"><code># Start up two containers in two terminal windows

$ sudo docker run -i -t --rm --net=none base /bin/bash
root@1f1f4c1f931a:/#

$ sudo docker run -i -t --rm --net=none base /bin/bash
root@12e343489d2f:/#

# Learn the container process IDs
# and create their namespace entries

$ sudo docker inspect -f '{{.State.Pid}}' 1f1f4c1f931a
2989
$ sudo docker inspect -f '{{.State.Pid}}' 12e343489d2f
3004
$ sudo mkdir -p /var/run/netns
$ sudo ln -s /proc/2989/ns/net /var/run/netns/2989
$ sudo ln -s /proc/3004/ns/net /var/run/netns/3004

# Create the "peer" interfaces and hand them out

$ sudo ip link add A type veth peer name B

$ sudo ip link set A netns 2989
$ sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A
$ sudo ip netns exec 2989 ip link set A up
$ sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A

$ sudo ip link set B netns 3004
$ sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B
$ sudo ip netns exec 3004 ip link set B up
$ sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B
</code></pre>
<p>The two containers should now be able to ping each other and make
connections successfully.  Point-to-point links like this do not depend
on a subnet nor a netmask, but on the bare assertion made by <code>ip route</code>
that some other single IP address is connected to a particular network
interface.</p>
<p>Note that point-to-point links can be safely combined with other kinds
of network connectivity — there is no need to start the containers with
<code>--net=none</code> if you want point-to-point links to be an addition to the
container's normal networking instead of a replacement.</p>
<p>A final permutation of this pattern is to create the point-to-point link
between the Docker host and one container, which would allow the host to
communicate with that one container on some single IP address and thus
communicate “out-of-band” of the bridge that connects the other, more
usual containers.  But unless you have very specific networking needs
that drive you to such a solution, it is probably far preferable to use
<code>--icc=false</code> to lock down inter-container communication, as we explored
earlier.</p>
<h2 id="editing-networking-config-files">Editing networking config files</h2>
<p>Starting with Docker v.1.2.0, you can now edit <code>/etc/hosts</code>, <code>/etc/hostname</code>
and <code>/etc/resolve.conf</code> in a running container. This is useful if you need
to install bind or other services that might override one of those files.</p>
<p>Note, however, that changes to these files will not be saved by
<code>docker commit</code>, nor will they be saved during <code>docker run</code>.
That means they won't be saved in the image, nor will they persist when a
container is restarted; they will only "stick" in a running container.</p>

      </div>
    </div>
  </div>

  <div id="push-footer"></div>

</div>



<div id="footer-container" class="container">
  <div id="footer" class="grey-body">
    <div class="row">
      <div class="span2">
        <span class="footer-title">Community</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/community/events/">Events</a></li>
          <li><a class="primary-button" href="http://posts.docker.com">Friends' Posts</a></li>
          <li><a class="primary-button" href="https://www.docker.com/community/meetups/">Meetups</a></li>
          <li><a class="primary-button" href="https://www.docker.com/community/governance/">Governance</a></li>
          <li><a class="primary-button" href="http://forums.docker.com">Forums</a></li>
          <li><a class="primary-button" href="http://botbot.me/freenode/docker">IRC</a></li>
          <li><a class="primary-button" href="https://github.com/docker/docker">GitHub</a></li>
          <li><a class="primary-button" href="http://stackoverflow.com/search?q=docker">Stackoverflow</a></li>
          <li><a class="primary-button" href="http://www.cafepress.com/docker">Swag</a></li>
        </ul>
      </div>
      <div class="span2">
        <span class="footer-title">Enterprise</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/enterprise/support/">Support</a></li>
          <li><a class="primary-button" href="https://www.docker.com/enterprise/education/">Education</a></li>
          <li><a class="primary-button" href="https://www.docker.com/enterprise/services/">Services</a></li>
        </ul>
        <span class="footer-title">Partner Solutions</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/partners/find/">Find a Partner</a></li>
          <li><a class="primary-button" href="https://www.docker.com/partners/program/">Partner Program</a></li>
          <li><a class="primary-button" href="https://www.docker.com/partners/learn/">Learn More</a></li>
        </ul>
      </div>
      <div class="span2">
        <span class="footer-title">Resources</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://docs.docker.com">Documentation</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/help/">Help</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/usecases/">Use Cases</a></li>
          <li><a class="primary-button" href="http://www.docker.com/tryit/">Online Tutorial</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/howtobuy/">How To Buy</a></li>
          <li><a class="primary-button" href="http://status.docker.com">Status</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/security/">Security</a></li>
        </ul>
      </div>
      <div class="span2">
        <span class="footer-title">Company</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/company/aboutus/">About Us</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/team/">Team</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/news/">News</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/press/">Press</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/careers/">Careers</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/contact/">Contact</a></li>
        </ul>
      </div>
      <div class="span3">
        <span class="footer-title">Connect</span>
        <div class="search">
          <span>Subscribe to our newsletter</span>
          <form action="https://www.docker.com/subscribe_newsletter/" method="post">
            <input type='hidden' name='csrfmiddlewaretoken' value='aWL78QXQkY8DSKNYh6cl08p5eTLl7sOa' />
            <tr><th><label for="id_email">Email:</label></th><td><input class="form-control" id="id_email" name="email" placeholder="Enter your email" type="text" /></td></tr>
            
            <button type="submit"><i class="icon-arrow-right"></i> </button>
          </form>
        </div>
        <ul class="unstyled social">
          <li><a title="Docker on Twitter" class="primary-button blog" href="http://blog.docker.com">Blog</a></li>
          <li><a title="Docker on Twitter" class="primary-button twitter" href="http://twitter.com/docker">Twitter</a></li>
          <li><a title="Docker on Google+" class="primary-button googleplus" href="https://plus.google.com/u/0/communities/108146856671494713993">Google+</a></li>
          <li><a title="Docker on Facebook" class="primary-button facebook" href="https://www.facebook.com/docker.run">Facebook</a></li>
          <li><a title="Docker on Youtube" class="primary-button youtube" href="http://www.youtube.com/user/dockerrun">YouTube</a></li>
        </ul>
        <ul class="unstyled social">
          <li><a title="Docker on SlideShare" class="primary-button slideshare" href="http://www.slideshare.net/Docker">Slideshare</a></li>
          <li>
             <a title="Docker on LinkedIn" class="primary-button" href="https://www.linkedin.com/company/docker">
                 <span class="linkedin"></span>
                 LinkedIn
             </a>
          </li>
          <li>
              <a title="Docker on GitHub" class="primary-button" href="https://github.com/docker/">
                  <span class="github"></span>
                  GitHub
              </a>
          </li>
          <li>
              <a title="Docker on Reddit" class="primary-button" href="http://www.reddit.com/r/docker">
                  <span class="reddit"></span>
                  Reddit
              </a>
          </li>
          <li>
              <a title="Docker on AngelList" class="primary-button" href="https://angel.co/docker-inc-1">
                  <span class="angellist"></span>
                  AngelList
              </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="row clearfix">
      <div class="span6 pagination-right copyright">
        <span>&copy; 2014-2015 Docker, Inc.</span>
      </div>
      <div class="span6 pagination-left copyright">
        <a href="http://www.docker.com/legal/terms_of_service">Terms</a> &middot;
        <a href="http://www.docker.com/legal/privacy_policy">Privacy</a> &middot;
        <a href="http://www.docker.com/legal/trademark_guidelines">Trademarks</a>
      </div>
    </div>
  </div>
</div>

<script src="/js/jquery-1.10.2.min.js"></script>
<script src="/js/jquery.cookie.js" ></script>
<script src="/js/jquery-scrolltofixed-min.js"></script>
<script src="/js/bootstrap-3.0.3.min.js"></script>
<script src="/js/prettify-1.0.min.js"></script>
<script src="/js/dockerfile_tutorial.js"></script>
<script src="/js/dockerfile_tutorial_level.js"></script>
<script src="/js/base.js"></script>
<script src="/tipuesearch/tipuesearch_set.js"></script>
<script src="/tipuesearch/tipuesearch.min.js"></script>
<script type="text/javascript">
piAId = '45082';
piCId = '1482';

(function() {
  function async_load(){
    var s = document.createElement('script'); s.type = 'text/javascript';
    s.src = ('https:' == document.location.protocol ? 'https://pi' : 'http://cdn') + '.pardot.com/pd.js';
    var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
  }
  if(window.attachEvent) { window.attachEvent('onload', async_load); }
  else { window.addEventListener('load', async_load, false); }
})();
</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('#content').css("min-height", $(window).height() - 553 );
    // if the URL contains a version string, update the version picker to reflect that
    version = document.location.pathname.match(/^\/(v\d\.\d)\/.*/)
    if (version && version[1]) {
        $('#document-version-number')[0].text = 'Version '+version[1];
    } else {
        $('#document-version-number')[0].text = $('#document-version-number')[0].text + " (Latest)"
    }
    // load the complete versions list
    $.get("/versions.html_fragment", function( data ) {
    	$('#documentation-version-list').prepend(data);
	//remove any "/v1.1/" bits from front, so we can add the path to the version selection dropdown.
	path = document.location.pathname.replace(/^\/v\d\.\d/, "");
	$('#documentation-version-list a.version').each(function(i, e) {
		e.href = e.href+path;
		$(e).removeClass()
	});
    });

  })
  var userName = getCookie('docker_sso_username');
  if (userName) {
    $('.topmostnav_loggedout').hide();
    $('.topmostnav_loggedin').show();
    $('#logged-in-header-username').text(userName);
  } else {
    $('.topmostnav_loggedout').show();
    $('.topmostnav_loggedin').hide();
  }
</script>
</body>
</html>