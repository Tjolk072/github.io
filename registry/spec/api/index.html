<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
  <meta name="docker_version" content="1.6.1">
  <meta name="docker_git_branch" content="master">
  <meta name="docker_git_commit" content="59cd467">
  <meta name="docker_build_date" content="Fri Jun  5 11:40:50 UTC 2015">

  <meta name="description" content="Explains how to use registry API">
  <meta name="keywords" content="registry, service, driver, images, storage, api">
  
  <link rel="canonical" href="/registry/spec/api/">
  <link href="/css/bootstrap-custom.css" rel="stylesheet">
  <link href="/css/main.css" rel="stylesheet">
  <link href="/css/prettify-1.0.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/dockerfile_tutorial.css">
  <link href="/tipuesearch
/tipuesearch.css" rel="stylesheet">
  <link href="/css/docs.css" rel="stylesheet">
  <link rel="shortcut icon" href="/img/favicon.png">
  <title>&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Registry Service API v2 - Docker Documentation</title>
  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
  <![endif]-->
  
  <script type="text/javascript">
	  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="4.0.0";
	  analytics.load("IWj9D0UpZHZdZUZX9jl98PcpBFWBnBMy");
	  analytics.page();
	  }}();
	</script>
  
</head>
<body>

<div id="topmostnav" class="topmostnav_loggedout navbar navbar-static-top">
  <div class="container">
    <a href="/" title="Docker Docs Home"><div class="brand logo"><img src="/img/nav/docker-logo-loggedin.png"> </div></a>
    <form id="nav_search" class="navbar-index-search pull-right" action="/jsearch/">
      <span role="status" aria-live="polite" class="ui-helper-hidden-accessible"></span>
      <input name="q" id="tipue_search_input" type="text" class="search_input search-query ui-autocomplete-input" placeholder="Search the Docs" autocomplete="off">
    </form>
    <ul class="nav">
      <li class=""><a href="http://www.docker.com/whatisdocker/" title="What is Docker">What is Docker?</a></li>
      <li class=""><a href="http://www.docker.com/resources/usecases/" title="Use Cases">Use Cases</a></li>
      <li class=""><a href="http://www.docker.com/tryit/" title="Try It!">Try It!</a></li>
      <li><a href="https://registry.hub.docker.com" title="Browse">Browse</a></li>
    </ul>
    <div id="usernav" class="pull-right">
      <a href="https://hub.docker.com/account/login" class="btn nav-button2" title="Lg In">Log In</a>
      <a href="https://hub.docker.com/account/signup" class="btn nav-button1" title="Sign Up">Sign Up</a>
    </div>
  </div>
</div>
<div id="topmostnav" class="topmostnav_loggedin navbar navbar-static-top">
  <div class="container">
    <a href="/" title="Docker Docs Home"><div class="brand logo"><img src="/img/nav/docker-logo-loggedin.png"> </div></a>
    <form id="nav_search" class="navbar-index-search pull-right" action="/jsearch/">
      <span role="status" aria-live="polite" class="ui-helper-hidden-accessible"></span>
      <input name="q" id="tipue_search_input" type="text" class="search_input search-query ui-autocomplete-input" placeholder="Search the Docs" autocomplete="off">
    </form>
    <ul class="nav">
      <li><a href="https://registry.hub.docker.com" title="Browse Repos">Browse Repos</a></li>
      <li class="active"><a href="http://docs.docker.com" title="Documentation">Documentation</a></li>
      <li><a href="http://www.docker.com/community/participate/" title="Community">Community</a></li>
      <li><a href="http://www.docker.com/resources/help/" title="Help">Help</a></li>
    </ul>
    <div id="usernav" class="pull-right">
      <ul class="nav user">
        <li class="dropdown">
          <a id="logged-in-header-username" class="dropdown-toggle" data-toggle="dropdown" href="#">
            <img class="profile" src="" alt="profile picture">
          </a>
          <ul class="dropdown-menu pull-right">
            <li><a href="https://hub.docker.com/">View Profile</a></li>
            <li><a href="https://hub.docker.com/account/settings/">Settings</a></li>
            <li><a href="https://hub.docker.com/repos/">My Repositories</a></li>
            <li><a href="https://hub.docker.com/plans/billing-info">Billing</a></li>
            <li><a href="https://hub.docker.com/account/logout/?next=/">Log out</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
</div>

<div id="wrap">
  <nav id="nav_menu" class="clearfix navbar navbar-default navbar-static-top affix" role="navigation">
  <div id="docsnav">
    <ul id="main-nav" class="pull-left">
      
      
      <li class="dd_menu pull-left">
        
        <a href="/">About</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/">Docker</a>
          </li>
        
          <li >
            <a href="/release-notes/">Release Notes</a>
          </li>
        
          <li >
            <a href="/introduction/understanding-docker/">Understanding Docker</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/installation/ubuntulinux/">Installation</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/installation/ubuntulinux/">Ubuntu</a>
          </li>
        
          <li >
            <a href="/installation/mac/">Mac OS X</a>
          </li>
        
          <li >
            <a href="/kitematic/">Kitematic on OS X</a>
          </li>
        
          <li >
            <a href="/installation/windows/">Microsoft Windows</a>
          </li>
        
          <li >
            <a href="/installation/testing-windows-docker-client/">Building and testing the Windows Docker client</a>
          </li>
        
          <li >
            <a href="/installation/amazon/">Amazon EC2</a>
          </li>
        
          <li >
            <a href="/installation/archlinux/">Arch Linux</a>
          </li>
        
          <li >
            <a href="/installation/binaries/">Binaries</a>
          </li>
        
          <li >
            <a href="/installation/centos/">CentOS</a>
          </li>
        
          <li >
            <a href="/installation/cruxlinux/">CRUX Linux</a>
          </li>
        
          <li >
            <a href="/installation/debian/">Debian</a>
          </li>
        
          <li >
            <a href="/installation/fedora/">Fedora</a>
          </li>
        
          <li >
            <a href="/installation/frugalware/">FrugalWare</a>
          </li>
        
          <li >
            <a href="/installation/google/">Google Cloud Platform</a>
          </li>
        
          <li >
            <a href="/installation/gentoolinux/">Gentoo</a>
          </li>
        
          <li >
            <a href="/installation/softlayer/">IBM Softlayer</a>
          </li>
        
          <li >
            <a href="/installation/joyent/">Joyent Compute Service</a>
          </li>
        
          <li >
            <a href="/installation/azure/">Microsoft Azure</a>
          </li>
        
          <li >
            <a href="/installation/rackspace/">Rackspace Cloud</a>
          </li>
        
          <li >
            <a href="/installation/rhel/">Red Hat Enterprise Linux</a>
          </li>
        
          <li >
            <a href="/installation/oracle/">Oracle Linux</a>
          </li>
        
          <li >
            <a href="/installation/SUSE/">SUSE</a>
          </li>
        
          <li >
            <a href="/compose/install/">Docker Compose</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/userguide/">User Guide</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/userguide/">The Docker User Guide</a>
          </li>
        
          <li >
            <a href="/userguide/dockerhub/">Getting Started with Docker Hub</a>
          </li>
        
          <li >
            <a href="/userguide/dockerizing/">Dockerizing Applications</a>
          </li>
        
          <li >
            <a href="/userguide/usingdocker/">Working with Containers</a>
          </li>
        
          <li >
            <a href="/userguide/dockerimages/">Working with Docker Images</a>
          </li>
        
          <li >
            <a href="/userguide/dockerlinks/">Linking containers together</a>
          </li>
        
          <li >
            <a href="/userguide/dockervolumes/">Managing data in containers</a>
          </li>
        
          <li >
            <a href="/userguide/labels-custom-metadata/">Apply custom metadata</a>
          </li>
        
          <li >
            <a href="/userguide/dockerrepos/">Working with Docker Hub</a>
          </li>
        
          <li >
            <a href="/compose/">Docker Compose</a>
          </li>
        
          <li >
            <a href="/compose/production/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Use Compose in production</a>
          </li>
        
          <li >
            <a href="/compose/extends/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Extend Compose services</a>
          </li>
        
          <li >
            <a href="/machine/">Docker Machine</a>
          </li>
        
          <li >
            <a href="/swarm/">Docker Swarm</a>
          </li>
        
          <li >
            <a href="/kitematic/userguide/">Kitematic</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/docker-hub/">Docker Hub</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/docker-hub/">Docker Hub</a>
          </li>
        
          <li >
            <a href="/docker-hub/accounts/">Accounts</a>
          </li>
        
          <li >
            <a href="/docker-hub/userguide/">User Guide</a>
          </li>
        
          <li >
            <a href="/docker-hub/repos/">Your Repositories</a>
          </li>
        
          <li >
            <a href="/docker-hub/builds/">Automated Builds</a>
          </li>
        
          <li >
            <a href="/docker-hub/official_repos/">Official Repositories</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/docker-hub-enterprise/">Docker Hub Enterprise</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/docker-hub-enterprise/">Overview</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/quick-start/">Quick Start: Basic Workflow</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/userguide/">User Guide</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/adminguide/">Admin Guide</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/install/">&nbsp;&nbsp;Installation</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/configuration/">&nbsp;&nbsp;Configuration options</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/support/">Support</a>
          </li>
        
          <li >
            <a href="/docker-hub-enterprise/release-notes/">Release notes</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/examples/nodejs_web_app/">Examples</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/examples/nodejs_web_app/">Dockerizing a Node.js web application</a>
          </li>
        
          <li >
            <a href="/examples/mongodb/">Dockerizing MongoDB</a>
          </li>
        
          <li >
            <a href="/examples/running_redis_service/">Dockerizing a Redis service</a>
          </li>
        
          <li >
            <a href="/examples/postgresql_service/">Dockerizing a PostgreSQL service</a>
          </li>
        
          <li >
            <a href="/examples/running_riak_service/">Dockerizing a Riak service</a>
          </li>
        
          <li >
            <a href="/examples/running_ssh_service/">Dockerizing an SSH service</a>
          </li>
        
          <li >
            <a href="/examples/couchdb_data_volumes/">Dockerizing a CouchDB service</a>
          </li>
        
          <li >
            <a href="/examples/apt-cacher-ng/">Dockerizing an Apt-Cacher-ng service</a>
          </li>
        
          <li >
            <a href="/compose/django/">Getting started with Compose and Django</a>
          </li>
        
          <li >
            <a href="/compose/rails/">Getting started with Compose and Rails</a>
          </li>
        
          <li >
            <a href="/compose/wordpress/">Getting started with Compose and Wordpress</a>
          </li>
        
          <li >
            <a href="/kitematic/minecraft-server/">Kitematic: Minecraft server</a>
          </li>
        
          <li >
            <a href="/kitematic/nginx-web-server/">Kitematic: Ngnix web server</a>
          </li>
        
          <li >
            <a href="/kitematic/rethinkdb-dev-database/">Kitematic: RethinkDB development database</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/articles/basics/">Articles</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/articles/basics/">Docker basics</a>
          </li>
        
          <li >
            <a href="/articles/networking/">Advanced networking</a>
          </li>
        
          <li >
            <a href="/articles/security/">Security</a>
          </li>
        
          <li >
            <a href="/articles/https/">Running Docker with HTTPS</a>
          </li>
        
          <li >
            <a href="/articles/registry_mirror/">Run a local registry mirror</a>
          </li>
        
          <li >
            <a href="/articles/host_integration/">Automatically starting containers</a>
          </li>
        
          <li >
            <a href="/articles/baseimages/">Creating a base image</a>
          </li>
        
          <li >
            <a href="/articles/dockerfile_best-practices/">Best practices for writing Dockerfiles</a>
          </li>
        
          <li >
            <a href="/articles/certificates/">Using certificates for repository client verification</a>
          </li>
        
          <li >
            <a href="/articles/using_supervisord/">Using Supervisor</a>
          </li>
        
          <li >
            <a href="/articles/configuring/">Configuring Docker</a>
          </li>
        
          <li >
            <a href="/articles/cfengine_process_management/">Process management with CFEngine</a>
          </li>
        
          <li >
            <a href="/articles/puppet/">Using Puppet</a>
          </li>
        
          <li >
            <a href="/articles/chef/">Using Chef</a>
          </li>
        
          <li >
            <a href="/articles/dsc/">Using PowerShell DSC</a>
          </li>
        
          <li >
            <a href="/articles/ambassador_pattern_linking/">Cross-Host linking using ambassador containers</a>
          </li>
        
          <li >
            <a href="/articles/runmetrics/">Runtime metrics</a>
          </li>
        
          <li >
            <a href="/articles/b2d_volume_resize/">Increasing a Boot2Docker volume</a>
          </li>
        
          <li >
            <a href="/articles/systemd/">Controlling and configuring Docker using Systemd</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left active">
        
        <a href="/reference/commandline/cli/">Reference</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/reference/commandline/cli/">Docker command line</a>
          </li>
        
          <li >
            <a href="/reference/builder/">Dockerfile</a>
          </li>
        
          <li >
            <a href="/faq/">FAQ</a>
          </li>
        
          <li >
            <a href="/reference/run/">Run Reference</a>
          </li>
        
          <li >
            <a href="/compose/cli/">Compose command line</a>
          </li>
        
          <li >
            <a href="/compose/yml/">Compose yml</a>
          </li>
        
          <li >
            <a href="/compose/env/">Compose ENV variables</a>
          </li>
        
          <li >
            <a href="/compose/completion/">Compose commandline completion</a>
          </li>
        
          <li >
            <a href="/swarm/discovery/">Swarm discovery</a>
          </li>
        
          <li >
            <a href="/swarm/scheduler/strategy/">Swarm strategies</a>
          </li>
        
          <li >
            <a href="/swarm/scheduler/filter/">Swarm filters</a>
          </li>
        
          <li >
            <a href="/swarm/API/">Swarm API</a>
          </li>
        
          <li >
            <a href="/registry/">Docker Registry 2.0</a>
          </li>
        
          <li >
            <a href="/registry/deploying/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Deploy a registry</a>
          </li>
        
          <li >
            <a href="/registry/configuration/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Configure a registry</a>
          </li>
        
          <li >
            <a href="/registry/storagedrivers/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Storage driver model</a>
          </li>
        
          <li >
            <a href="/registry/notifications/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Work with notifications</a>
          </li>
        
          <li class="active">
            <a href="/registry/spec/api/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Registry Service API v2</a>
          </li>
        
          <li >
            <a href="/registry/spec/json/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; JSON format</a>
          </li>
        
          <li >
            <a href="/registry/spec/auth/token/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp; Authenticate via central service</a>
          </li>
        
          <li >
            <a href="/reference/api/hub_registry_spec/">Docker Hub and Registry 1.0</a>
          </li>
        
          <li >
            <a href="/reference/api/registry_api/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp;Docker Registry API v1</a>
          </li>
        
          <li >
            <a href="/reference/api/registry_api_client_libraries/">&nbsp;&nbsp;&nbsp;&nbsp;&blacksquare;&nbsp;Docker Registry 1.0 API Client Libraries</a>
          </li>
        
          <li >
            <a href="/reference/api/docker-io_api/">Docker Hub API</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api/">Docker Remote API</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api_v1.18/">Docker Remote API v1.18</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api_v1.17/">Docker Remote API v1.17</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_remote_api_v1.16/">Docker Remote API v1.16</a>
          </li>
        
          <li >
            <a href="/reference/api/remote_api_client_libraries/">Docker Remote API client libraries</a>
          </li>
        
          <li >
            <a href="/reference/api/docker_io_accounts_api/">Docker Hub accounts API</a>
          </li>
        
          <li >
            <a href="/kitematic/faq/">Kitematic: FAQ</a>
          </li>
        
          <li >
            <a href="/kitematic/known-issues/">Kitematic: Known issues</a>
          </li>
        
        </ul>
      </li>
      
      
      
      <li class="dd_menu pull-left">
        
        <a href="/project/who-written-for/">Contributor</a>
        
        <ul class="dd_submenu" style="max-height: 75px;">
        
          <li >
            <a href="/project/who-written-for/">README first</a>
          </li>
        
          <li >
            <a href="/project/software-required/">Get required software for Linux or OS X</a>
          </li>
        
          <li >
            <a href="/project/software-req-win/">Get required software for Windows</a>
          </li>
        
          <li >
            <a href="/project/set-up-git/">Configure Git for contributing</a>
          </li>
        
          <li >
            <a href="/project/set-up-dev-env/">Work with a development container</a>
          </li>
        
          <li >
            <a href="/project/test-and-docs/">Run tests and test documentation</a>
          </li>
        
          <li >
            <a href="/project/make-a-contribution/">Understand contribution workflow</a>
          </li>
        
          <li >
            <a href="/project/find-an-issue/">Find an issue</a>
          </li>
        
          <li >
            <a href="/project/work-issue/">Work on an issue</a>
          </li>
        
          <li >
            <a href="/project/create-pr/">Create a pull request</a>
          </li>
        
          <li >
            <a href="/project/review-pr/">Participate in the PR review</a>
          </li>
        
          <li >
            <a href="/project/advanced-contributing/">Advanced contributing</a>
          </li>
        
          <li >
            <a href="/project/get-help/">Where to get help</a>
          </li>
        
          <li >
            <a href="/project/coding-style/">Coding style guide</a>
          </li>
        
          <li >
            <a href="/project/doc-style/">Documentation style guide</a>
          </li>
        
        </ul>
      </li>
      
      
    </ul>
  </div>
</nav>
  <div id="content" class="container">
    <div class="row">

      <div class="span3" id="leftnav">
        <div id="toc_table">
          <ul class="nav nav-tabs nav-stacked">
            
  
    <li class=""><a href="#introduction">Introduction</a>
      <ul>
    
      <li><a href="#scope">Scope</a></li>
    
      <li><a href="#use-cases">Use Cases</a></li>
    
      <li><a href="#changes">Changes</a></li>
    
      </ul>
    </li>
  
    <li class=""><a href="#overview">Overview</a>
      <ul>
    
      <li><a href="#errors">Errors</a></li>
    
      <li><a href="#api-version-check">API Version Check</a></li>
    
      <li><a href="#pulling-an-image">Pulling An Image</a></li>
    
      <li><a href="#pushing-an-image">Pushing An Image</a></li>
    
      <li><a href="#deleting-an-image">Deleting an Image</a></li>
    
      </ul>
    </li>
  
    <li class=""><a href="#detail">Detail</a>
      <ul>
    
      <li><a href="#errors_2">Errors</a></li>
    
      <li><a href="#base">Base</a></li>
    
      <li><a href="#tags">Tags</a></li>
    
      <li><a href="#manifest">Manifest</a></li>
    
      <li><a href="#blob">Blob</a></li>
    
      <li><a href="#intiate-blob-upload">Intiate Blob Upload</a></li>
    
      <li><a href="#blob-upload">Blob Upload</a></li>
    
      </ul>
    </li>
  

          </ul>
        </div>
      </div>
      <div class="span9 content-body">

        

        <h1 id="docker-registry-http-api-v2">Docker Registry HTTP API V2</h1>
<h2 id="introduction">Introduction</h2>
<p>The <em>Docker Registry HTTP API</em> is the protocol to facilitate distribution of
images to the docker engine. It interacts with instances of the docker
registry, which is a service to manage information about docker images and
enable their distribution. The specification covers the operation of version 2
of this API, known as <em>Docker Registry HTTP API V2</em>.</p>
<p>While the V1 registry protocol is usable, there are several problems with the
architecture that have led to this new version. The main driver of this
specification these changes to the docker the image format, covered in
docker/docker#8093. The new, self-contained image manifest simplifies image
definition and improves security. This specification will build on that work,
leveraging new properties of the manifest format to improve performance,
reduce bandwidth usage and decrease the likelihood of backend corruption.</p>
<p>For relevant details and history leading up to this specification, please see
the following issues:</p>
<ul>
<li><a href="https://github.com/docker/docker/issues/8093">docker/docker#8093</a></li>
<li><a href="https://github.com/docker/docker/issues/9015">docker/docker#9015</a></li>
<li><a href="https://github.com/docker/docker-registry/issues/612">docker/docker-registry#612</a></li>
</ul>
<h3 id="scope">Scope</h3>
<p>This specification covers the URL layout and protocols of the interaction
between docker registry and docker core. This will affect the docker core
registry API and the rewrite of docker-registry. Docker registry
implementations may implement other API endpoints, but they are not covered by
this specification.</p>
<p>This includes the following features:</p>
<ul>
<li>Namespace-oriented URI Layout</li>
<li>PUSH/PULL registry server for V2 image manifest format</li>
<li>Resumable layer PUSH support</li>
<li>V2 Client library implementation</li>
</ul>
<p>While authentication and authorization support will influence this
specification, details of the protocol will be left to a future specification.
Relevant header definitions and error codes are present to provide an
indication of what a client may encounter.</p>
<h4 id="future">Future</h4>
<p>There are features that have been discussed during the process of cutting this
specification. The following is an incomplete list:</p>
<ul>
<li>Immutable image references</li>
<li>Multiple architecture support</li>
<li>Migration from v2compatibility representation</li>
</ul>
<p>These may represent features that are either out of the scope of this
specification, the purview of another specification or have been deferred to a
future version.</p>
<h3 id="use-cases">Use Cases</h3>
<p>For the most part, the use cases of the former registry API apply to the new
version. Differentiating use cases are covered below.</p>
<h4 id="image-verification">Image Verification</h4>
<p>A docker engine instance would like to run verified image named
"library/ubuntu", with the tag "latest". The engine contacts the registry,
requesting the manifest for "library/ubuntu:latest". An untrusted registry
returns a manifest. Before proceeding to download the individual layers, the
engine verifies the manifest's signature, ensuring that the content was
produced from a trusted source and no tampering has occured. After each layer
is downloaded, the engine verifies the digest of the layer, ensuring that the
content matches that specified by the manifest.</p>
<h4 id="resumable-push">Resumable Push</h4>
<p>Company X's build servers lose connectivity to docker registry before
completing an image layer transfer. After connectivity returns, the build
server attempts to re-upload the image. The registry notifies the build server
that the upload has already been partially attempted. The build server
responds by only sending the remaining data to complete the image file.</p>
<h4 id="resumable-pull">Resumable Pull</h4>
<p>Company X is having more connectivity problems but this time in their
deployment datacenter. When downloading an image, the connection is
interrupted before completion. The client keeps the partial data and uses http
<code>Range</code> requests to avoid downloading repeated data.</p>
<h4 id="layer-upload-de-duplication">Layer Upload De-duplication</h4>
<p>Company Y's build system creates two identical docker layers from build
processes A and B. Build process A completes uploading the layer before B.
When process B attempts to upload the layer, the registry indicates that its
not necessary because the layer is already known.</p>
<p>If process A and B upload the same layer at the same time, both operations
will proceed and the first to complete will be stored in the registry (Note:
we may modify this to prevent dogpile with some locking mechanism).</p>
<h3 id="changes">Changes</h3>
<p>The V2 specification has been written to work as a living document, specifying
only what is certain and leaving what is not specified open or to future
changes. Only non-conflicting additions should be made to the API and accepted
changes should avoid preventing future changes from happening.</p>
<p>This section should be updated when changes are made to the specification,
indicating what is different. Optionally, we may start marking parts of the
specification to correspond with the versions enumerated here.</p>
<dl>
    <dt>2.0.1</dt>
    <dd>
        <ul>
            <li>Added capability of doing streaming upload to PATCH blob upload.</li>
            <li>Updated PUT blob upload to no longer take final chunk, now requires entire data or no data.</li>
            <li>Removed `416 Requested Range Not Satisfiable` response status from PUT blob upload.</li>
        </ul>
    </dd>

    <dt>2.0.0</dt>
    <dd>
        <ul>
            <li>Added support for immutable manifest references in manifest endpoints.</li>
            <li>Deleting a manifest by tag has been deprecated.</li>
            <li>Specified `Docker-Content-Digest` header for appropriate entities.</li>
            <li>Added error code for unsupported operations.</li>
            <li>Added capability of doing streaming upload to PATCH blob upload.</li>
            <li>Updated PUT blob upload to no longer take final chunk, now requires entire data or no data.</li>
            <li>Removed 416 return code from PUT blob upload.</li>
        </ul>
    </dd>

    <dt>2.0</dt>
    <dd>
        This is the baseline specification.
    </dd>
</dl>

<h2 id="overview">Overview</h2>
<p>This section covers client flows and details of the API endpoints. The URI
layout of the new API is structured to support a rich authentication and
authorization model by leveraging namespaces. All endpoints will be prefixed
by the API version and the repository name:</p>
<pre class="prettyprint well"><code>/v2/&lt;name&gt;/
</code></pre>
<p>For example, an API endpoint that will work with the <code>library/ubuntu</code>
repository, the URI prefix will be:</p>
<pre class="prettyprint well"><code>/v2/library/ubuntu/
</code></pre>
<p>This scheme provides rich access control over various operations and methods
using the URI prefix and http methods that can be controlled in variety of
ways.</p>
<p>Classically, repository names have always been two path components where each
path component is less than 30 characters. The V2 registry API does not
enforce this. The rules for a repository name are as follows:</p>
<ol>
<li>A repository name is broken up into <em>path components</em>. A component of a
   repository name must be at least two lowercase, alpha-numeric characters,
   optionally separated by periods, dashes or underscores. More strictly, it
   must match the regular expression <code>[a-z0-9]+(?:[._-][a-z0-9]+)*</code> and the
   matched result must be 2 or more characters in length.</li>
<li>The name of a repository must have at least two path components, separated
   by a forward slash.</li>
<li>The total length of a repository name, including slashes, must be less the
   256 characters.</li>
</ol>
<p>These name requirements <em>only</em> apply to the registry API and should accept a
superset of what is supported by other docker ecosystem components.</p>
<p>All endpoints should support aggressive http caching, compression and range
headers, where appropriate. The new API attempts to leverage HTTP semantics
where possible but may break from standards to implement targeted features.</p>
<p>For detail on individual endpoints, please see the <a href="#detail"><em>Detail</em></a>
section.</p>
<h3 id="errors">Errors</h3>
<p>Actionable failure conditions, covered in detail in their relevant sections,
are reported as part of 4xx responses, in a json response body. One or more
errors will be returned in the following format:</p>
<pre class="prettyprint well"><code>{
    "errors:" [{
            "code": &lt;error identifier&gt;,
            "message": &lt;message describing condition&gt;,
            "detail": &lt;unstructured&gt;
        },
        ...
    ]
}
</code></pre>
<p>The <code>code</code> field will be a unique identifier, all caps with underscores by
convention. The <code>message</code> field will be a human readable string. The optional
<code>detail</code> field may contain arbitrary json data providing information the
client can use to resolve the issue.</p>
<p>While the client can take action on certain error codes, the registry may add
new error codes over time. All client implementations should treat unknown
error codes as <code>UNKNOWN</code>, allowing future error codes to be added without
breaking API compatibility. For the purposes of the specification error codes
will only be added and never removed.</p>
<p>For a complete account of all error codes, please see the <em>Detail</em> section.</p>
<h3 id="api-version-check">API Version Check</h3>
<p>A minimal endpoint, mounted at <code>/v2/</code> will provide version support information
based on its response statuses. The request format is as follows:</p>
<pre class="prettyprint well"><code>GET /v2/
</code></pre>
<p>If a <code>200 OK</code> response is returned, the registry implements the V2(.1)
registry API and the client may proceed safely with other V2 operations.
Optionally, the response may contain information about the supported paths in
the response body. The client should be prepared to ignore this data.</p>
<p>If a <code>401 Unauthorized</code> response is returned, the client should take action
based on the contents of the "WWW-Authenticate" header and try the endpoint
again. Depending on access control setup, the client may still have to
authenticate against different resources, even if this check succeeds.</p>
<p>If <code>404 Not Found</code> response status, or other unexpected status, is returned,
the client should proceed with the assumption that the registry does not
implement V2 of the API.</p>
<p>When a <code>200 OK</code> or <code>401 Unauthorized</code> response is returned, the
"Docker-Distribution-API-Version" header should be set to "registry/2.0".
Clients may require this header value to determine if the endpoint serves this
API. When this header is omitted, clients may fallback to an older API version.</p>
<h3 id="pulling-an-image">Pulling An Image</h3>
<p>An "image" is a combination of a JSON manifest and individual layer files. The
process of pulling an image centers around retrieving these two components.</p>
<p>The first step in pulling an image is to retrieve the manifest. For reference,
the relevant manifest fields for the registry are the following:</p>
<table>
<thead>
<tr>
<th>field</th>
<th>description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>The name of the image.</td>
<td></td>
</tr>
<tr>
<td>tag</td>
<td>The tag for this version of the image.</td>
<td></td>
</tr>
<tr>
<td>fsLayers</td>
<td>A list of layer descriptors (including tarsum)</td>
<td></td>
</tr>
<tr>
<td>signature</td>
<td>A JWS used to verify the manifest content</td>
<td></td>
</tr>
</tbody>
</table>
<p>For more information about the manifest format, please see
<a href="https://github.com/docker/docker/issues/8093">docker/docker#8093</a>.</p>
<p>When the manifest is in hand, the client must verify the signature to ensure
the names and layers are valid. Once confirmed, the client will then use the
tarsums to download the individual layers. Layers are stored in as blobs in
the V2 registry API, keyed by their tarsum digest.</p>
<h4 id="pulling-an-image-manifest">Pulling an Image Manifest</h4>
<p>The image manifest can be fetched with the following url:</p>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;
</code></pre>

<p>The <code>name</code> and <code>reference</code> parameter identify the image and are required. The
reference may include a tag or digest.</p>
<p>A <code>404 Not Found</code> response will be returned if the image is unknown to the
registry. If the image exists and the response is successful, the image
manifest will be returned, with the following format (see docker/docker#8093
for details):</p>
<pre class="prettyprint well"><code>{
   "name": &lt;name&gt;,
   "tag": &lt;tag&gt;,
   "fsLayers": [
      {
         "blobSum": &lt;tarsum&gt;
      },
      ...
    ]
   ],
   "history": &lt;v1 images&gt;,
   "signature": &lt;JWS&gt;
}
</code></pre>
<p>The client should verify the returned manifest signature for authenticity
before fetching layers.</p>
<h4 id="pulling-a-layer">Pulling a Layer</h4>
<p>Layers are stored in the blob portion of the registry, keyed by tarsum digest.
Pulling a layer is carried out by a standard http request. The URL is as
follows:</p>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/blobs/&lt;tarsum&gt;
</code></pre>
<p>Access to a layer will be gated by the <code>name</code> of the repository but is
identified uniquely in the registry by <code>tarsum</code>. The <code>tarsum</code> parameter is an
opaque field, to be interpreted by the tarsum library.</p>
<p>This endpoint may issue a 307 (302 for &lt;HTTP 1.1) redirect to another service
for downloading the layer and clients should be prepared to handle redirects.</p>
<p>This endpoint should support aggressive HTTP caching for image layers. Support
for Etags, modification dates and other cache control headers should be
included. To allow for incremental downloads, <code>Range</code> requests should be
supported, as well.</p>
<h3 id="pushing-an-image">Pushing An Image</h3>
<p>Pushing an image works in the opposite order as a pull. After assembling the
image manifest, the client must first push the individual layers. When the
layers are fully pushed into the registry, the client should upload the signed
manifest.</p>
<p>The details of each step of the process are covered in the following sections.</p>
<h4 id="pushing-a-layer">Pushing a Layer</h4>
<p>All layer uploads use two steps to manage the upload process. The first step
starts the upload in the registry service, returning a url to carry out the
second step. The second step uses the upload url to transfer the actual data.
Uploads are started with a POST request which returns a url that can be used
to push data and check upload status.</p>
<p>The <code>Location</code> header will be used to communicate the upload location after
each request. While it won't change in the this specification, clients should
use the most recent value returned by the API.</p>
<h5 id="starting-an-upload">Starting An Upload</h5>
<p>To begin the process, a POST request should be issued in the following format:</p>
<pre class="prettyprint well"><code>POST /v2/&lt;name&gt;/blobs/uploads/
</code></pre>

<p>The parameters of this request are the image namespace under which the layer
will be linked. Responses to this request are covered below.</p>
<h5 id="existing-layers">Existing Layers</h5>
<p>The existence of a layer can be checked via a <code>HEAD</code> request to the blob store
API. The request should be formatted as follows:</p>
<pre class="prettyprint well"><code>HEAD /v2/&lt;name&gt;/blobs/&lt;digest&gt;
</code></pre>

<p>If the layer with the tarsum specified in <code>digest</code> is available, a 200 OK
response will be received, with no actual body content (this is according to
http specification). The response will look as follows:</p>
<pre class="prettyprint well"><code>200 OK
Content-Length: &lt;length of blob&gt;
Docker-Content-Digest: &lt;digest&gt;
</code></pre>

<p>When this response is received, the client can assume that the layer is
already available in the registry under the given name and should take no
further action to upload the layer. Note that the binary digests may differ
for the existing registry layer, but the tarsums will be guaranteed to match.</p>
<h5 id="uploading-the-layer">Uploading the Layer</h5>
<p>If the POST request is successful, a <code>202 Accepted</code> response will be returned
with the upload URL in the <code>Location</code> header:</p>
<pre class="prettyprint well"><code>202 Accepted
Location: /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Range: bytes=0-&lt;offset&gt;
Content-Length: 0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>The rest of the upload process can be carried out with the returned url,
called the "Upload URL" from the <code>Location</code> header. All responses to the
upload url, whether sending data or getting status, will be in this format.
Though the URI format (<code>/v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;</code>) for the <code>Location</code>
header is specified, clients should treat it as an opaque url and should never
try to assemble the it. While the <code>uuid</code> parameter may be an actual UUID, this
proposal imposes no constraints on the format and clients should never impose
any.</p>
<p>If clients need to correlate local upload state with remote upload state, the
contents of the <code>Docker-Upload-UUID</code> header should be used. Such an id can be
used to key the last used location header when implementing resumable uploads.</p>
<h5 id="upload-progress">Upload Progress</h5>
<p>The progress and chunk coordination of the upload process will be coordinated
through the <code>Range</code> header. While this is a non-standard use of the <code>Range</code>
header, there are examples of <a href="https://developers.google.com/youtube/v3/guides/using_resumable_upload_protocol">similar approaches</a> in APIs with heavy use.
For an upload that just started, for an example with a 1000 byte layer file,
the <code>Range</code> header would be as follows:</p>
<pre class="prettyprint well"><code>Range: bytes=0-0
</code></pre>

<p>To get the status of an upload, issue a GET request to the upload URL:</p>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Host: &lt;registry host&gt;
</code></pre>

<p>The response will be similar to the above, except will return 204 status:</p>
<pre class="prettyprint well"><code>204 No Content
Location: /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Range: bytes=0-&lt;offset&gt;
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>Note that the HTTP <code>Range</code> header byte ranges are inclusive and that will be
honored, even in non-standard use cases.</p>
<h5 id="monolithic-upload">Monolithic Upload</h5>
<p>A monolithic upload is simply a chunked upload with a single chunk and may be
favored by clients that would like to avoided the complexity of chunking. To
carry out a "monolithic" upload, one can simply put the entire content blob to
the provided URL:</p>
<pre class="prettyprint well"><code>PUT /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;?digest=&lt;tarsum&gt;[&amp;digest=sha256:&lt;hex digest&gt;]
Content-Length: &lt;size of layer&gt;
Content-Type: application/octet-stream

&lt;Layer Binary Data&gt;
</code></pre>

<p>The "digest" parameter must be included with the PUT request. Please see the
<em>Completed Upload</em> section for details on the parameters and expected
responses.</p>
<p>Additionally, the upload can be completed with a single <code>POST</code> request to
the uploads endpoint, including the "size" and "digest" parameters:</p>
<pre class="prettyprint well"><code>POST /v2/&lt;name&gt;/blobs/uploads/?digest=&lt;tarsum&gt;[&amp;digest=sha256:&lt;hex digest&gt;]
Content-Length: &lt;size of layer&gt;
Content-Type: application/octet-stream

&lt;Layer Binary Data&gt;
</code></pre>

<p>On the registry service, this should allocate a download, accept and verify
the data and return the same  response as the final chunk of an upload. If the
POST request fails collecting the data in any way, the registry should attempt
to return an error response to the client with the <code>Location</code> header providing
a place to continue the download.</p>
<p>The single <code>POST</code> method is provided for convenience and most clients should
implement <code>POST</code> + <code>PUT</code> to support reliable resume of uploads.</p>
<h5 id="chunked-upload">Chunked Upload</h5>
<p>To carry out an upload of a chunk, the client can specify a range header and
only include that part of the layer file:</p>
<pre class="prettyprint well"><code>PATCH /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Content-Length: &lt;size of chunk&gt;
Content-Range: &lt;start of range&gt;-&lt;end of range&gt;
Content-Type: application/octet-stream

&lt;Layer Chunk Binary Data&gt;
</code></pre>

<p>There is no enforcement on layer chunk splits other than that the server must
receive them in order. The server may enforce a minimum chunk size. If the
server cannot accept the chunk, a <code>416 Requested Range Not Satisfiable</code>
response will be returned and will include a <code>Range</code> header indicating the
current status:</p>
<pre class="prettyprint well"><code>416 Requested Range Not Satisfiable
Location: /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Range: 0-&lt;last valid range&gt;
Content-Length: 0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>If this response is received, the client should resume from the "last valid
range" and upload the subsequent chunk. A 416 will be returned under the
following conditions:</p>
<ul>
<li>Invalid Content-Range header format</li>
<li>Out of order chunk: the range of the next chunk must start immediately after
  the "last valid range" from the previous response.</li>
</ul>
<p>When a chunk is accepted as part of the upload, a <code>202 Accepted</code> response will
be returned, including a <code>Range</code> header with the current upload status:</p>
<pre class="prettyprint well"><code>202 Accepted
Location: /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Range: bytes=0-&lt;offset&gt;
Content-Length: 0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<h5 id="completed-upload">Completed Upload</h5>
<p>For an upload to be considered complete, the client must submit a <code>PUT</code>
request on the upload endpoint with a digest parameter. If it is not provided,
the upload will not be considered complete. The format for the final chunk
will be as follows:</p>
<pre class="prettyprint well"><code>PUT /v2/&lt;name&gt;/blob/uploads/&lt;uuid&gt;?digest=&lt;tarsum&gt;[&amp;digest=sha256:&lt;hex digest&gt;]
Content-Length: &lt;size of chunk&gt;
Content-Range: &lt;start of range&gt;-&lt;end of range&gt;
Content-Type: application/octet-stream

&lt;Last Layer Chunk Binary Data&gt;
</code></pre>

<p>Optionally, if all chunks have already been uploaded, a <code>PUT</code> request with a
<code>digest</code> parameter and zero-length body may be sent to complete and validated
the upload. Multiple "digest" parameters may be provided with different
digests. The server may verify none or all of them but <em>must</em> notify the
client if the content is rejected.</p>
<p>When the last chunk is received and the layer has been validated, the client
will receive a <code>201 Created</code> response:</p>
<pre class="prettyprint well"><code>201 Created
Location: /v2/&lt;name&gt;/blobs/&lt;tarsum&gt;
Content-Length: 0
Docker-Content-Digest: &lt;digest&gt;
</code></pre>

<p>The <code>Location</code> header will contain the registry URL to access the accepted
layer file. The <code>Docker-Content-Digest</code> header returns the canonical digest of
the uploaded blob which may differ from the provided digest. Most clients may
ignore the value but if it is used, the client should verify the value against
the uploaded blob data.</p>
<h6 id="digest-parameter">Digest Parameter</h6>
<p>The "digest" parameter is designed as an opaque parameter to support
verification of a successful transfer. The initial version of the registry API
will support a tarsum digest, in the standard tarsum format. For example, a
HTTP URI parameter might be as follows:</p>
<pre class="prettyprint well"><code>tarsum.v1+sha256:6c3c624b58dbbcd3c0dd82b4c53f04194d1247c6eebdaab7c610cf7d66709b3b
</code></pre>

<p>Given this parameter, the registry will verify that the provided content does
result in this tarsum. Optionally, the registry can support other other digest
parameters for non-tarfile content stored as a layer. A regular hash digest
might be specified as follows:</p>
<pre class="prettyprint well"><code>sha256:6c3c624b58dbbcd3c0dd82b4c53f04194d1247c6eebdaab7c610cf7d66709b3b
</code></pre>

<p>Such a parameter would be used to verify that the binary content (as opposed
to the tar content) would be verified at the end of the upload process.</p>
<p>For the initial version, registry servers are only required to support the
tarsum format.</p>
<h5 id="canceling-an-upload">Canceling an Upload</h5>
<p>An upload can be cancelled by issuing a DELETE request to the upload endpoint.
The format will be as follows:</p>
<pre class="prettyprint well"><code>DELETE /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
</code></pre>

<p>After this request is issued, the upload uuid will no longer be valid and the
registry server will dump all intermediate data. While uploads will time out
if not completed, clients should issue this request if they encounter a fatal
error but still have the ability to issue an http request.</p>
<h5 id="errors_1">Errors</h5>
<p>If an 502, 503 or 504 error is received, the client should assume that the
download can proceed due to a temporary condition, honoring the appropriate
retry mechanism. Other 5xx errors should be treated as terminal.</p>
<p>If there is a problem with the upload, a 4xx error will be returned indicating
the problem. After receiving a 4xx response (except 416, as called out above),
the upload will be considered failed and the client should take appropriate
action.</p>
<p>Note that the upload url will not be available forever. If the upload uuid is
unknown to the registry, a <code>404 Not Found</code> response will be returned and the
client must restart the upload process.</p>
<h4 id="pushing-an-image-manifest">Pushing an Image Manifest</h4>
<p>Once all of the layers for an image are uploaded, the client can upload the
image manifest. An image can be pushed using the following request format:</p>
<pre class="prettyprint well"><code>PUT /v2/&lt;name&gt;/manifests/&lt;reference&gt;

{
   "name": &lt;name&gt;,
   "tag": &lt;tag&gt;,
   "fsLayers": [
      {
         "blobSum": &lt;tarsum&gt;
      },
      ...
    ]
   ],
   "history": &lt;v1 images&gt;,
   "signature": &lt;JWS&gt;,
   ...
}
</code></pre>
<p>The <code>name</code> and <code>reference</code> fields of the response body must match those specified in
the URL. The <code>reference</code> field may be a "tag" or a "digest".</p>
<p>If there is a problem with pushing the manifest, a relevant 4xx response will
be returned with a JSON error message. Please see the _PUT Manifest section
for details on possible error codes that may be returned.</p>
<p>If one or more layers are unknown to the registry, <code>BLOB_UNKNOWN</code> errors are
returned. The <code>detail</code> field of the error response will have a <code>digest</code> field
identifying the missing blob, which will be a tarsum. An error is returned for
each unknown blob. The response format is as follows:</p>
<pre class="prettyprint well"><code>{
    "errors:" [{
            "code": "BLOB_UNKNOWN",
            "message": "blob unknown to registry",
            "detail": {
                "digest": &lt;tarsum&gt;
            }
        },
        ...
    ]
}
</code></pre>
<h4 id="listing-image-tags">Listing Image Tags</h4>
<p>It may be necessary to list all of the tags under a given repository. The tags
for an image repository can be retrieved with the following request:</p>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/tags/list
</code></pre>
<p>The response will be in the following format:</p>
<pre class="prettyprint well"><code>200 OK
Content-Type: application/json

{
    "name": &lt;name&gt;,
    "tags": [
        &lt;tag&gt;,
        ...
    ]
}
</code></pre>
<p>For repositories with a large number of tags, this response may be quite
large, so care should be taken by the client when parsing the response to
reduce copying.</p>
<h3 id="deleting-an-image">Deleting an Image</h3>
<p>An image may be deleted from the registry via its <code>name</code> and <code>reference</code>. A
delete may be issued with the following request format:</p>
<pre class="prettyprint well"><code>DELETE /v2/&lt;name&gt;/manifests/&lt;reference&gt;
</code></pre>
<p>For deletes, <code>reference</code> <em>must</em> be a digest or the delete will fail. If the
image exists and has been successfully deleted, the following response will be
issued:</p>
<pre class="prettyprint well"><code>202 Accepted
Content-Length: None
</code></pre>
<p>If the image had already been deleted or did not exist, a <code>404 Not Found</code>
response will be issued instead.</p>
<h2 id="detail">Detail</h2>
<blockquote>
<p><strong>Note</strong>: This section is still under construction. For the purposes of
implementation, if any details below differ from the described request flows
above, the section below should be corrected. When they match, this note
should be removed.</p>
</blockquote>
<p>The behavior of the endpoints are covered in detail in this section, organized
by route and entity. All aspects of the request and responses are covered,
including headers, parameters and body formats. Examples of requests and their
corresponding responses, with success and failure, are enumerated.</p>
<blockquote>
<p><strong>Note</strong>: The sections on endpoint detail are arranged with an example
request, a description of the request, followed by information about that
request.</p>
</blockquote>
<p>A list of methods and URIs are covered in the table below:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Path</th>
<th>Entity</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><code>/v2/</code></td>
<td>Base</td>
<td>Check that the endpoint implements Docker Registry API V2.</td>
</tr>
<tr>
<td>GET</td>
<td><code>/v2/&lt;name&gt;/tags/list</code></td>
<td>Tags</td>
<td>Fetch the tags under the repository identified by <code>name</code>.</td>
</tr>
<tr>
<td>GET</td>
<td><code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></td>
<td>Manifest</td>
<td>Fetch the manifest identified by <code>name</code> and <code>reference</code> where <code>reference</code> can be a tag or digest.</td>
</tr>
<tr>
<td>PUT</td>
<td><code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></td>
<td>Manifest</td>
<td>Put the manifest identified by <code>name</code> and <code>reference</code> where <code>reference</code> can be a tag or digest.</td>
</tr>
<tr>
<td>DELETE</td>
<td><code>/v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></td>
<td>Manifest</td>
<td>Delete the manifest identified by <code>name</code> and <code>reference</code> where <code>reference</code> can be a tag or digest.</td>
</tr>
<tr>
<td>GET</td>
<td><code>/v2/&lt;name&gt;/blobs/&lt;digest&gt;</code></td>
<td>Blob</td>
<td>Retrieve the blob from the registry identified by <code>digest</code>. A <code>HEAD</code> request can also be issued to this endpoint to obtain resource information without receiving all data.</td>
</tr>
<tr>
<td>POST</td>
<td><code>/v2/&lt;name&gt;/blobs/uploads/</code></td>
<td>Intiate Blob Upload</td>
<td>Initiate a resumable blob upload. If successful, an upload location will be provided to complete the upload. Optionally, if the <code>digest</code> parameter is present, the request body will be used to complete the upload in a single request.</td>
</tr>
<tr>
<td>GET</td>
<td><code>/v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;</code></td>
<td>Blob Upload</td>
<td>Retrieve status of upload identified by <code>uuid</code>. The primary purpose of this endpoint is to resolve the current status of a resumable upload.</td>
</tr>
<tr>
<td>PATCH</td>
<td><code>/v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;</code></td>
<td>Blob Upload</td>
<td>Upload a chunk of data for the specified upload.</td>
</tr>
<tr>
<td>PUT</td>
<td><code>/v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;</code></td>
<td>Blob Upload</td>
<td>Complete the upload specified by <code>uuid</code>, optionally appending the body as the final chunk.</td>
</tr>
<tr>
<td>DELETE</td>
<td><code>/v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;</code></td>
<td>Blob Upload</td>
<td>Cancel outstanding upload processes, releasing associated resources. If this is not called, the unfinished uploads will eventually timeout.</td>
</tr>
</tbody>
</table>
<p>The detail for each endpoint is covered in the following sections.</p>
<h3 id="errors_2">Errors</h3>
<p>The error codes encountered via the API are enumerated in the following table:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNKNOWN</code></td>
<td>unknown error</td>
<td>Generic error returned when the error does not have an API classification.</td>
<td></td>
</tr>
<tr>
<td><code>UNSUPPORTED</code></td>
<td>The operation is unsupported.</td>
<td>The operation was unsupported due to a missing implementation or invalid set of parameters.</td>
<td></td>
</tr>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
<tr>
<td><code>SIZE_INVALID</code></td>
<td>provided length did not match content length</td>
<td>When a layer is uploaded, the provided size will be checked against the uploaded content. If they do not match, this error will be returned.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>TAG_INVALID</code></td>
<td>manifest tag did not match URI</td>
<td>During a manifest upload, if the tag in the manifest does not match the uri tag, this error will be returned.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_UNKNOWN</code></td>
<td>repository name not known to registry</td>
<td>This is returned if the name used during an operation is unknown to the registry.</td>
<td></td>
</tr>
<tr>
<td><code>MANIFEST_UNKNOWN</code></td>
<td>manifest unknown</td>
<td>This error is returned when the manifest, identified by name and tag is unknown to the repository.</td>
<td></td>
</tr>
<tr>
<td><code>MANIFEST_INVALID</code></td>
<td>manifest invalid</td>
<td>During upload, manifests undergo several checks ensuring validity. If those checks fail, this error may be returned, unless a more specific error is included. The detail will contain information the failed validation.</td>
<td></td>
</tr>
<tr>
<td><code>MANIFEST_UNVERIFIED</code></td>
<td>manifest failed signature verification</td>
<td>During manifest upload, if the manifest fails signature verification, this error will be returned.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UNKNOWN</code></td>
<td>blob unknown to registry</td>
<td>This error may be returned when a blob is unknown to the registry in a specified repository. This can be returned with a standard get or if a manifest references an unknown layer during upload.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UPLOAD_UNKNOWN</code></td>
<td>blob upload unknown to registry</td>
<td>If a blob upload has been cancelled or was never started, this error code may be returned.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UPLOAD_INVALID</code></td>
<td>blob upload invalid</td>
<td>The blob upload encountered an error and can no longer proceed.</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="base">Base</h3>
<p>Base V2 API route. Typically, this can be used for lightweight version checks and to validate registry authorization.</p>
<h4 id="get-base">GET Base</h4>
<p>Check that the endpoint implements Docker Registry API V2.</p>
<pre class="prettyprint well"><code>GET /v2/
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
</code></pre>

<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-ok">On Success: OK</h6>
<pre class="prettyprint well"><code>200 OK
</code></pre>

<p>The API implements V2 protocol and is accessible.</p>
<h6 id="on-failure-unauthorized">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client is not authorized to access the registry.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
</code></pre>

<p>The registry does not implement the V2 API.</p>
<h3 id="tags">Tags</h3>
<p>Retrieve information about tags.</p>
<h4 id="get-tags">GET Tags</h4>
<p>Fetch the tags under the repository identified by <code>name</code>.</p>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/tags/list
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
</code></pre>

<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-ok_1">On Success: OK</h6>
<pre class="prettyprint well"><code>200 OK
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;name&quot;: &lt;name&gt;,
    &quot;tags&quot;: [
        &lt;tag&gt;,
        ...
    ]
}
</code></pre>

<p>A list of tags for the named repository.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON response body.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_1">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The repository is not known to the registry.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_UNKNOWN</code></td>
<td>repository name not known to registry</td>
<td>This is returned if the name used during an operation is unknown to the registry.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_1">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to the repository.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="manifest">Manifest</h3>
<p>Create, update and retrieve manifests.</p>
<h4 id="get-manifest">GET Manifest</h4>
<p>Fetch the manifest identified by <code>name</code> and <code>reference</code> where <code>reference</code> can be a tag or digest.</p>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
</code></pre>

<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>tag</code></td>
<td>path</td>
<td>Tag of the target manifiest.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-ok_2">On Success: OK</h6>
<pre class="prettyprint well"><code>200 OK
Docker-Content-Digest: &lt;digest&gt;
Content-Type: application/json; charset=utf-8

{
   &quot;name&quot;: &lt;name&gt;,
   &quot;tag&quot;: &lt;tag&gt;,
   &quot;fsLayers&quot;: [
      {
         &quot;blobSum&quot;: &quot;&lt;digest&gt;&quot;
      },
      ...
    ]
   ],
   &quot;history&quot;: &lt;v1 images&gt;,
   &quot;signature&quot;: &lt;JWS&gt;
}
</code></pre>

<p>The manifest idenfied by <code>name</code> and <code>reference</code>. The contents can be used to identify and resolve resources required to run the specified image.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Docker-Content-Digest</code></td>
<td>Digest of the targeted content for the request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The name or reference was invalid.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>TAG_INVALID</code></td>
<td>manifest tag did not match URI</td>
<td>During a manifest upload, if the tag in the manifest does not match the uri tag, this error will be returned.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_2">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to the repository.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_2">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The named manifest is not known to the registry.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_UNKNOWN</code></td>
<td>repository name not known to registry</td>
<td>This is returned if the name used during an operation is unknown to the registry.</td>
<td></td>
</tr>
<tr>
<td><code>MANIFEST_UNKNOWN</code></td>
<td>manifest unknown</td>
<td>This error is returned when the manifest, identified by name and tag is unknown to the repository.</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="put-manifest">PUT Manifest</h4>
<p>Put the manifest identified by <code>name</code> and <code>reference</code> where <code>reference</code> can be a tag or digest.</p>
<pre class="prettyprint well"><code>PUT /v2/&lt;name&gt;/manifests/&lt;reference&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Content-Type: application/json; charset=utf-8

{
   &quot;name&quot;: &lt;name&gt;,
   &quot;tag&quot;: &lt;tag&gt;,
   &quot;fsLayers&quot;: [
      {
         &quot;blobSum&quot;: &quot;&lt;digest&gt;&quot;
      },
      ...
    ]
   ],
   &quot;history&quot;: &lt;v1 images&gt;,
   &quot;signature&quot;: &lt;JWS&gt;
}
</code></pre>

<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>tag</code></td>
<td>path</td>
<td>Tag of the target manifiest.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-accepted">On Success: Accepted</h6>
<pre class="prettyprint well"><code>202 Accepted
Location: &lt;url&gt;
Content-Length: 0
Docker-Content-Digest: &lt;digest&gt;
</code></pre>

<p>The manifest has been accepted by the registry and is stored under the specified <code>name</code> and <code>tag</code>.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Location</code></td>
<td>The canonical location url of the uploaded manifest.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>Docker-Content-Digest</code></td>
<td>Digest of the targeted content for the request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-invalid-manifest">On Failure: Invalid Manifest</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The received manifest was invalid in some way, as described by the error codes. The client should resolve the issue and retry the request.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>TAG_INVALID</code></td>
<td>manifest tag did not match URI</td>
<td>During a manifest upload, if the tag in the manifest does not match the uri tag, this error will be returned.</td>
<td></td>
</tr>
<tr>
<td><code>MANIFEST_INVALID</code></td>
<td>manifest invalid</td>
<td>During upload, manifests undergo several checks ensuring validity. If those checks fail, this error may be returned, unless a more specific error is included. The detail will contain information the failed validation.</td>
<td></td>
</tr>
<tr>
<td><code>MANIFEST_UNVERIFIED</code></td>
<td>manifest failed signature verification</td>
<td>During manifest upload, if the manifest fails signature verification, this error will be returned.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UNKNOWN</code></td>
<td>blob unknown to registry</td>
<td>This error may be returned when a blob is unknown to the registry in a specified repository. This can be returned with a standard get or if a manifest references an unknown layer during upload.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_3">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have permission to push to the repository.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-missing-layers">On Failure: Missing Layer(s)</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [{
            &quot;code&quot;: &quot;BLOB_UNKNOWN&quot;,
            &quot;message&quot;: &quot;blob unknown to registry&quot;,
            &quot;detail&quot;: {
                &quot;digest&quot;: &quot;&lt;digest&gt;&quot;
            }
        },
        ...
    ]
}
</code></pre>

<p>One or more layers may be missing during a manifest upload. If so, the missing layers will be enumerated in the error response.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BLOB_UNKNOWN</code></td>
<td>blob unknown to registry</td>
<td>This error may be returned when a blob is unknown to the registry in a specified repository. This can be returned with a standard get or if a manifest references an unknown layer during upload.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_4">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="delete-manifest">DELETE Manifest</h4>
<p>Delete the manifest identified by <code>name</code> and <code>reference</code> where <code>reference</code> can be a tag or digest.</p>
<pre class="prettyprint well"><code>DELETE /v2/&lt;name&gt;/manifests/&lt;reference&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
</code></pre>

<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>tag</code></td>
<td>path</td>
<td>Tag of the target manifiest.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-accepted_1">On Success: Accepted</h6>
<pre class="prettyprint well"><code>202 Accepted
</code></pre>

<h6 id="on-failure-invalid-name-or-tag">On Failure: Invalid Name or Tag</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The specified <code>name</code> or <code>tag</code> were invalid and the delete was unable to proceed.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>TAG_INVALID</code></td>
<td>manifest tag did not match URI</td>
<td>During a manifest upload, if the tag in the manifest does not match the uri tag, this error will be returned.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_5">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unknown-manifest">On Failure: Unknown Manifest</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The specified <code>name</code> or <code>tag</code> are unknown to the registry and the delete was unable to proceed. Clients can assume the manifest was already deleted if this response is returned.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_UNKNOWN</code></td>
<td>repository name not known to registry</td>
<td>This is returned if the name used during an operation is unknown to the registry.</td>
<td></td>
</tr>
<tr>
<td><code>MANIFEST_UNKNOWN</code></td>
<td>manifest unknown</td>
<td>This error is returned when the manifest, identified by name and tag is unknown to the repository.</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="blob">Blob</h3>
<p>Fetch the blob identified by <code>name</code> and <code>digest</code>. Used to fetch layers by digest.</p>
<h4 id="get-blob">GET Blob</h4>
<p>Retrieve the blob from the registry identified by <code>digest</code>. A <code>HEAD</code> request can also be issued to this endpoint to obtain resource information without receiving all data.</p>
<h5 id="fetch-blob">Fetch Blob</h5>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
</code></pre>

<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>digest</code></td>
<td>path</td>
<td>Digest of desired blob.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-ok_3">On Success: OK</h6>
<pre class="prettyprint well"><code>200 OK
Content-Length: &lt;length&gt;
Docker-Content-Digest: &lt;digest&gt;
Content-Type: application/octet-stream

&lt;blob binary data&gt;
</code></pre>

<p>The blob identified by <code>digest</code> is available. The blob content will be present in the body of the request.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Content-Length</code></td>
<td>The length of the requested blob content.</td>
</tr>
<tr>
<td><code>Docker-Content-Digest</code></td>
<td>Digest of the targeted content for the request.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-temporary-redirect">On Success: Temporary Redirect</h6>
<pre class="prettyprint well"><code>307 Temporary Redirect
Location: &lt;blob location&gt;
Docker-Content-Digest: &lt;digest&gt;
</code></pre>

<p>The blob identified by <code>digest</code> is available at the provided location.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Location</code></td>
<td>The location where the layer should be accessible.</td>
</tr>
<tr>
<td><code>Docker-Content-Digest</code></td>
<td>Digest of the targeted content for the request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request_1">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>There was a problem with the request that needs to be addressed by the client, such as an invalid <code>name</code> or <code>tag</code>.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_6">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_3">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The blob, identified by <code>name</code> and <code>digest</code>, is unknown to the registry.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_UNKNOWN</code></td>
<td>repository name not known to registry</td>
<td>This is returned if the name used during an operation is unknown to the registry.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UNKNOWN</code></td>
<td>blob unknown to registry</td>
<td>This error may be returned when a blob is unknown to the registry in a specified repository. This can be returned with a standard get or if a manifest references an unknown layer during upload.</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="fetch-blob-part">Fetch Blob Part</h5>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Range: bytes=&lt;start&gt;-&lt;end&gt;
</code></pre>

<p>This endpoint may also support RFC7233 compliant range requests. Support can be detected by issuing a HEAD request. If the header <code>Accept-Range: bytes</code> is returned, range requests can be used to fetch partial content.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>Range</code></td>
<td>header</td>
<td>HTTP Range header specifying blob chunk.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>digest</code></td>
<td>path</td>
<td>Digest of desired blob.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-partial-content">On Success: Partial Content</h6>
<pre class="prettyprint well"><code>206 Partial Content
Content-Length: &lt;length&gt;
Content-Range: bytes &lt;start&gt;-&lt;end&gt;/&lt;size&gt;
Content-Type: application/octet-stream

&lt;blob binary data&gt;
</code></pre>

<p>The blob identified by <code>digest</code> is available. The specified chunk of blob content will be present in the body of the request.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Content-Length</code></td>
<td>The length of the requested blob chunk.</td>
</tr>
<tr>
<td><code>Content-Range</code></td>
<td>Content range of blob chunk.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request_2">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>There was a problem with the request that needs to be addressed by the client, such as an invalid <code>name</code> or <code>tag</code>.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_7">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_4">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_UNKNOWN</code></td>
<td>repository name not known to registry</td>
<td>This is returned if the name used during an operation is unknown to the registry.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UNKNOWN</code></td>
<td>blob unknown to registry</td>
<td>This error may be returned when a blob is unknown to the registry in a specified repository. This can be returned with a standard get or if a manifest references an unknown layer during upload.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-requested-range-not-satisfiable">On Failure: Requested Range Not Satisfiable</h6>
<pre class="prettyprint well"><code>416 Requested Range Not Satisfiable
</code></pre>

<p>The range specification cannot be satisfied for the requested content. This can happen when the range is not formatted correctly or if the range is outside of the valid size of the content.</p>
<h3 id="intiate-blob-upload">Intiate Blob Upload</h3>
<p>Initiate a blob upload. This endpoint can be used to create resumable uploads or monolithic uploads.</p>
<h4 id="post-intiate-blob-upload">POST Intiate Blob Upload</h4>
<p>Initiate a resumable blob upload. If successful, an upload location will be provided to complete the upload. Optionally, if the <code>digest</code> parameter is present, the request body will be used to complete the upload in a single request.</p>
<h5 id="initiate-monolithic-blob-upload">Initiate Monolithic Blob Upload</h5>
<pre class="prettyprint well"><code>POST /v2/&lt;name&gt;/blobs/uploads/?digest=&lt;digest&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Content-Length: &lt;length of blob&gt;
Content-Type: application/octect-stream

&lt;binary data&gt;
</code></pre>

<p>Upload a blob identified by the <code>digest</code> parameter in single request. This upload will not be resumable unless a recoverable error is returned.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>header</td>
<td></td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>digest</code></td>
<td>query</td>
<td>Digest of uploaded blob. If present, the upload will be completed, in a single request, with contents of the request body as the resulting blob.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-created">On Success: Created</h6>
<pre class="prettyprint well"><code>201 Created
Location: &lt;blob location&gt;
Content-Length: 0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>The blob has been created in the registry and is available at the provided location.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Location</code></td>
<td></td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>Docker-Upload-UUID</code></td>
<td>Identifies the docker upload uuid for the current request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-invalid-name-or-digest">On Failure: Invalid Name or Digest</h6>
<pre class="prettyprint well"><code>400 Bad Request
</code></pre>

<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_8">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to push to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="initiate-resumable-blob-upload">Initiate Resumable Blob Upload</h5>
<pre class="prettyprint well"><code>POST /v2/&lt;name&gt;/blobs/uploads/
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Content-Length: 0
</code></pre>

<p>Initiate a resumable blob upload with an empty request body.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>header</td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-accepted_2">On Success: Accepted</h6>
<pre class="prettyprint well"><code>202 Accepted
Content-Length: 0
Location: /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Range: 0-0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>The upload has been created. The <code>Location</code> header must be used to complete the upload. The response should be identical to a <code>GET</code> request on the contents of the returned <code>Location</code> header.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>Location</code></td>
<td>The location of the created upload. Clients should use the contents verbatim to complete the upload, adding parameters where required.</td>
</tr>
<tr>
<td><code>Range</code></td>
<td>Range header indicating the progress of the upload. When starting an upload, it will return an empty range, since no content has been received.</td>
</tr>
<tr>
<td><code>Docker-Upload-UUID</code></td>
<td>Identifies the docker upload uuid for the current request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-invalid-name-or-digest_1">On Failure: Invalid Name or Digest</h6>
<pre class="prettyprint well"><code>400 Bad Request
</code></pre>

<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_9">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to push to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="blob-upload">Blob Upload</h3>
<p>Interact with blob uploads. Clients should never assemble URLs for this endpoint and should only take it through the <code>Location</code> header on related API requests. The <code>Location</code> header and its parameters should be preserved by clients, using the latest value returned via upload related API calls.</p>
<h4 id="get-blob-upload">GET Blob Upload</h4>
<p>Retrieve status of upload identified by <code>uuid</code>. The primary purpose of this endpoint is to resolve the current status of a resumable upload.</p>
<pre class="prettyprint well"><code>GET /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
</code></pre>

<p>Retrieve the progress of the current upload, as reported by the <code>Range</code> header.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>path</td>
<td>A uuid identifying the upload. This field can accept characters that match <code>[a-zA-Z0-9-_.=]+</code>.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-upload-progress">On Success: Upload Progress</h6>
<pre class="prettyprint well"><code>204 No Content
Range: 0-&lt;offset&gt;
Content-Length: 0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>The upload is known and in progress. The last received offset is available in the <code>Range</code> header.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Range</code></td>
<td>Range indicating the current progress of the upload.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>Docker-Upload-UUID</code></td>
<td>Identifies the docker upload uuid for the current request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request_3">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>There was an error processing the upload and it must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UPLOAD_INVALID</code></td>
<td>blob upload invalid</td>
<td>The blob upload encountered an error and can no longer proceed.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_10">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_5">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The upload is unknown to the registry. The upload must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BLOB_UPLOAD_UNKNOWN</code></td>
<td>blob upload unknown to registry</td>
<td>If a blob upload has been cancelled or was never started, this error code may be returned.</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="patch-blob-upload">PATCH Blob Upload</h4>
<p>Upload a chunk of data for the specified upload.</p>
<h5 id="stream-upload">Stream upload</h5>
<pre class="prettyprint well"><code>PATCH /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Content-Type: application/octet-stream

&lt;binary data&gt;
</code></pre>

<p>Upload a stream of data to upload without completing the upload.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>path</td>
<td>A uuid identifying the upload. This field can accept characters that match <code>[a-zA-Z0-9-_.=]+</code>.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-data-accepted">On Success: Data Accepted</h6>
<pre class="prettyprint well"><code>204 No Content
Location: /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Range: 0-&lt;offset&gt;
Content-Length: 0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>The stream of data has been accepted and the current progress is available in the range header. The updated upload location is available in the <code>Location</code> header.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Location</code></td>
<td>The location of the upload. Clients should assume this changes after each request. Clients should use the contents verbatim to complete the upload, adding parameters where required.</td>
</tr>
<tr>
<td><code>Range</code></td>
<td>Range indicating the current progress of the upload.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>Docker-Upload-UUID</code></td>
<td>Identifies the docker upload uuid for the current request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request_4">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>There was an error processing the upload and it must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UPLOAD_INVALID</code></td>
<td>blob upload invalid</td>
<td>The blob upload encountered an error and can no longer proceed.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_11">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to push to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_6">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The upload is unknown to the registry. The upload must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BLOB_UPLOAD_UNKNOWN</code></td>
<td>blob upload unknown to registry</td>
<td>If a blob upload has been cancelled or was never started, this error code may be returned.</td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="chunked-upload_1">Chunked upload</h5>
<pre class="prettyprint well"><code>PATCH /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Content-Range: &lt;start of range&gt;-&lt;end of range, inclusive&gt;
Content-Length: &lt;length of chunk&gt;
Content-Type: application/octet-stream

&lt;binary chunk&gt;
</code></pre>

<p>Upload a chunk of data to specified upload without completing the upload. The data will be uploaded to the specified Content Range.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>Content-Range</code></td>
<td>header</td>
<td>Range of bytes identifying the desired block of content represented by the body. Start must the end offset retrieved via status check plus one. Note that this is a non-standard use of the <code>Content-Range</code> header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>header</td>
<td>Length of the chunk being uploaded, corresponding the length of the request body.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>path</td>
<td>A uuid identifying the upload. This field can accept characters that match <code>[a-zA-Z0-9-_.=]+</code>.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-chunk-accepted">On Success: Chunk Accepted</h6>
<pre class="prettyprint well"><code>204 No Content
Location: /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Range: 0-&lt;offset&gt;
Content-Length: 0
Docker-Upload-UUID: &lt;uuid&gt;
</code></pre>

<p>The chunk of data has been accepted and the current progress is available in the range header. The updated upload location is available in the <code>Location</code> header.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Location</code></td>
<td>The location of the upload. Clients should assume this changes after each request. Clients should use the contents verbatim to complete the upload, adding parameters where required.</td>
</tr>
<tr>
<td><code>Range</code></td>
<td>Range indicating the current progress of the upload.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>Docker-Upload-UUID</code></td>
<td>Identifies the docker upload uuid for the current request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request_5">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>There was an error processing the upload and it must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UPLOAD_INVALID</code></td>
<td>blob upload invalid</td>
<td>The blob upload encountered an error and can no longer proceed.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_12">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to push to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_7">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The upload is unknown to the registry. The upload must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BLOB_UPLOAD_UNKNOWN</code></td>
<td>blob upload unknown to registry</td>
<td>If a blob upload has been cancelled or was never started, this error code may be returned.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-requested-range-not-satisfiable_1">On Failure: Requested Range Not Satisfiable</h6>
<pre class="prettyprint well"><code>416 Requested Range Not Satisfiable
</code></pre>

<p>The <code>Content-Range</code> specification cannot be accepted, either because it does not overlap with the current progress or it is invalid.</p>
<h4 id="put-blob-upload">PUT Blob Upload</h4>
<p>Complete the upload specified by <code>uuid</code>, optionally appending the body as the final chunk.</p>
<pre class="prettyprint well"><code>PUT /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;?digest=&lt;digest&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Content-Length: &lt;length of data&gt;
Content-Type: application/octet-stream

&lt;binary data&gt;
</code></pre>

<p>Complete the upload, providing all the data in the body, if necessary. A request without a body will just complete the upload with previously uploaded content.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>header</td>
<td>Length of the data being uploaded, corresponding to the length of the request body. May be zero if no data is provided.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>path</td>
<td>A uuid identifying the upload. This field can accept characters that match <code>[a-zA-Z0-9-_.=]+</code>.</td>
</tr>
<tr>
<td><code>digest</code></td>
<td>query</td>
<td>Digest of uploaded blob.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-upload-complete">On Success: Upload Complete</h6>
<pre class="prettyprint well"><code>204 No Content
Location: &lt;blob location&gt;
Content-Range: &lt;start of range&gt;-&lt;end of range, inclusive&gt;
Content-Length: 0
Docker-Content-Digest: &lt;digest&gt;
</code></pre>

<p>The upload has been completed and accepted by the registry. The canonical location will be available in the <code>Location</code> header.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Location</code></td>
<td>The canonical location of the blob for retrieval</td>
</tr>
<tr>
<td><code>Content-Range</code></td>
<td>Range of bytes identifying the desired block of content represented by the body. Start must match the end of offset retrieved via status check. Note that this is a non-standard use of the <code>Content-Range</code> header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>Docker-Content-Digest</code></td>
<td>Digest of the targeted content for the request.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request_6">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>There was an error processing the upload and it must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DIGEST_INVALID</code></td>
<td>provided digest did not match uploaded content</td>
<td>When a blob is uploaded, the registry will check that the content matches the digest provided by the client. The error may include a detail structure with the key "digest", including the invalid digest string. This error may also be returned when a manifest includes an invalid layer digest.</td>
<td></td>
</tr>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UPLOAD_INVALID</code></td>
<td>blob upload invalid</td>
<td>The blob upload encountered an error and can no longer proceed.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_13">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to push to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_8">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The upload is unknown to the registry. The upload must be restarted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BLOB_UPLOAD_UNKNOWN</code></td>
<td>blob upload unknown to registry</td>
<td>If a blob upload has been cancelled or was never started, this error code may be returned.</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="delete-blob-upload">DELETE Blob Upload</h4>
<p>Cancel outstanding upload processes, releasing associated resources. If this is not called, the unfinished uploads will eventually timeout.</p>
<pre class="prettyprint well"><code>DELETE /v2/&lt;name&gt;/blobs/uploads/&lt;uuid&gt;
Host: &lt;registry host&gt;
Authorization: &lt;scheme&gt; &lt;token&gt;
Content-Length: 0
</code></pre>

<p>Cancel the upload specified by <code>uuid</code>.</p>
<p>The following parameters should be specified on the request:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Kind</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td>header</td>
<td>Standard HTTP Host Header. Should be set to the registry host.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td>header</td>
<td>An RFC7235 compliant authorization header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>header</td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>path</td>
<td>Name of the target repository.</td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>path</td>
<td>A uuid identifying the upload. This field can accept characters that match <code>[a-zA-Z0-9-_.=]+</code>.</td>
</tr>
</tbody>
</table>
<h6 id="on-success-upload-deleted">On Success: Upload Deleted</h6>
<pre class="prettyprint well"><code>204 No Content
Content-Length: 0
</code></pre>

<p>The upload has been successfully deleted.</p>
<p>The following headers will be returned with the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Content-Length</code></td>
<td>The <code>Content-Length</code> header must be zero and the body must be empty.</td>
</tr>
</tbody>
</table>
<h6 id="on-failure-bad-request_7">On Failure: Bad Request</h6>
<pre class="prettyprint well"><code>400 Bad Request
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>An error was encountered processing the delete. The client may ignore this error.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NAME_INVALID</code></td>
<td>invalid repository name</td>
<td>Invalid repository name encountered either during manifest validation or any API operation.</td>
<td></td>
</tr>
<tr>
<td><code>BLOB_UPLOAD_INVALID</code></td>
<td>blob upload invalid</td>
<td>The blob upload encountered an error and can no longer proceed.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-unauthorized_14">On Failure: Unauthorized</h6>
<pre class="prettyprint well"><code>401 Unauthorized
WWW-Authenticate: &lt;scheme&gt; realm=&quot;&lt;realm&gt;&quot;, ...&quot;
Content-Length: &lt;length&gt;
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &quot;UNAUTHORIZED&quot;,
            &quot;message&quot;: &quot;access to the requested resource is not authorized&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The client does not have access to the repository.</p>
<p>The following headers will be returned on the response:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WWW-Authenticate</code></td>
<td>An RFC7235 compliant authentication challenge header.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td>Length of the JSON error response body.</td>
</tr>
</tbody>
</table>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UNAUTHORIZED</code></td>
<td>access to the requested resource is not authorized</td>
<td>The access controller denied access for the operation on a resource. Often this will be accompanied by a 401 Unauthorized response status.</td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="on-failure-not-found_9">On Failure: Not Found</h6>
<pre class="prettyprint well"><code>404 Not Found
Content-Type: application/json; charset=utf-8

{
    &quot;errors:&quot; [
        {
            &quot;code&quot;: &lt;error code&gt;,
            &quot;message&quot;: &quot;&lt;error message&gt;&quot;,
            &quot;detail&quot;: ...
        },
        ...
    ]
}
</code></pre>

<p>The upload is unknown to the registry. The client may ignore this error and assume the upload has been deleted.</p>
<p>The error codes that may be included in the response body are enumerated below:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BLOB_UPLOAD_UNKNOWN</code></td>
<td>blob upload unknown to registry</td>
<td>If a blob upload has been cancelled or was never started, this error code may be returned.</td>
<td></td>
</tr>
</tbody>
</table>

      </div>
    </div>
  </div>

  <div id="push-footer"></div>

</div>



<div id="footer-container" class="container">
  <div id="footer" class="grey-body">
    <div class="row">
      <div class="span2">
        <span class="footer-title">Community</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/community/events/">Events</a></li>
          <li><a class="primary-button" href="http://posts.docker.com">Friends' Posts</a></li>
          <li><a class="primary-button" href="https://www.docker.com/community/meetups/">Meetups</a></li>
          <li><a class="primary-button" href="https://www.docker.com/community/governance/">Governance</a></li>
          <li><a class="primary-button" href="http://forums.docker.com">Forums</a></li>
          <li><a class="primary-button" href="http://botbot.me/freenode/docker">IRC</a></li>
          <li><a class="primary-button" href="https://github.com/docker/docker">GitHub</a></li>
          <li><a class="primary-button" href="http://stackoverflow.com/search?q=docker">Stackoverflow</a></li>
          <li><a class="primary-button" href="http://www.cafepress.com/docker">Swag</a></li>
        </ul>
      </div>
      <div class="span2">
        <span class="footer-title">Enterprise</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/enterprise/support/">Support</a></li>
          <li><a class="primary-button" href="https://www.docker.com/enterprise/education/">Education</a></li>
          <li><a class="primary-button" href="https://www.docker.com/enterprise/services/">Services</a></li>
        </ul>
        <span class="footer-title">Partner Solutions</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/partners/find/">Find a Partner</a></li>
          <li><a class="primary-button" href="https://www.docker.com/partners/program/">Partner Program</a></li>
          <li><a class="primary-button" href="https://www.docker.com/partners/learn/">Learn More</a></li>
        </ul>
      </div>
      <div class="span2">
        <span class="footer-title">Resources</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://docs.docker.com">Documentation</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/help/">Help</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/usecases/">Use Cases</a></li>
          <li><a class="primary-button" href="http://www.docker.com/tryit/">Online Tutorial</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/howtobuy/">How To Buy</a></li>
          <li><a class="primary-button" href="http://status.docker.com">Status</a></li>
          <li><a class="primary-button" href="https://www.docker.com/resources/security/">Security</a></li>
        </ul>
      </div>
      <div class="span2">
        <span class="footer-title">Company</span>
        <ul class="unstyled">
          <li><a class="primary-button" href="https://www.docker.com/company/aboutus/">About Us</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/team/">Team</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/news/">News</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/press/">Press</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/careers/">Careers</a></li>
          <li><a class="primary-button" href="https://www.docker.com/company/contact/">Contact</a></li>
        </ul>
      </div>
      <div class="span3">
        <span class="footer-title">Connect</span>
        <div class="search">
          <span>Subscribe to our newsletter</span>
          <form action="https://www.docker.com/subscribe_newsletter/" method="post">
            <input type='hidden' name='csrfmiddlewaretoken' value='aWL78QXQkY8DSKNYh6cl08p5eTLl7sOa' />
            <tr><th><label for="id_email">Email:</label></th><td><input class="form-control" id="id_email" name="email" placeholder="Enter your email" type="text" /></td></tr>
            
            <button type="submit"><i class="icon-arrow-right"></i> </button>
          </form>
        </div>
        <ul class="unstyled social">
          <li><a title="Docker on Twitter" class="primary-button blog" href="http://blog.docker.com">Blog</a></li>
          <li><a title="Docker on Twitter" class="primary-button twitter" href="http://twitter.com/docker">Twitter</a></li>
          <li><a title="Docker on Google+" class="primary-button googleplus" href="https://plus.google.com/u/0/communities/108146856671494713993">Google+</a></li>
          <li><a title="Docker on Facebook" class="primary-button facebook" href="https://www.facebook.com/docker.run">Facebook</a></li>
          <li><a title="Docker on Youtube" class="primary-button youtube" href="http://www.youtube.com/user/dockerrun">YouTube</a></li>
        </ul>
        <ul class="unstyled social">
          <li><a title="Docker on SlideShare" class="primary-button slideshare" href="http://www.slideshare.net/Docker">Slideshare</a></li>
          <li>
             <a title="Docker on LinkedIn" class="primary-button" href="https://www.linkedin.com/company/docker">
                 <span class="linkedin"></span>
                 LinkedIn
             </a>
          </li>
          <li>
              <a title="Docker on GitHub" class="primary-button" href="https://github.com/docker/">
                  <span class="github"></span>
                  GitHub
              </a>
          </li>
          <li>
              <a title="Docker on Reddit" class="primary-button" href="http://www.reddit.com/r/docker">
                  <span class="reddit"></span>
                  Reddit
              </a>
          </li>
          <li>
              <a title="Docker on AngelList" class="primary-button" href="https://angel.co/docker-inc-1">
                  <span class="angellist"></span>
                  AngelList
              </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="row clearfix">
      <div class="span6 pagination-right copyright">
        <span>&copy; 2014-2015 Docker, Inc.</span>
      </div>
      <div class="span6 pagination-left copyright">
        <a href="http://www.docker.com/legal/terms_of_service">Terms</a> &middot;
        <a href="http://www.docker.com/legal/privacy_policy">Privacy</a> &middot;
        <a href="http://www.docker.com/legal/trademark_guidelines">Trademarks</a>
      </div>
    </div>
  </div>
</div>

<script src="/js/jquery-1.10.2.min.js"></script>
<script src="/js/jquery.cookie.js" ></script>
<script src="/js/jquery-scrolltofixed-min.js"></script>
<script src="/js/bootstrap-3.0.3.min.js"></script>
<script src="/js/prettify-1.0.min.js"></script>
<script src="/js/dockerfile_tutorial.js"></script>
<script src="/js/dockerfile_tutorial_level.js"></script>
<script src="/js/base.js"></script>
<script src="/tipuesearch/tipuesearch_set.js"></script>
<script src="/tipuesearch/tipuesearch.min.js"></script>
<script type="text/javascript">
piAId = '45082';
piCId = '1482';

(function() {
  function async_load(){
    var s = document.createElement('script'); s.type = 'text/javascript';
    s.src = ('https:' == document.location.protocol ? 'https://pi' : 'http://cdn') + '.pardot.com/pd.js';
    var c = document.getElementsByTagName('script')[0]; c.parentNode.insertBefore(s, c);
  }
  if(window.attachEvent) { window.attachEvent('onload', async_load); }
  else { window.addEventListener('load', async_load, false); }
})();
</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('#content').css("min-height", $(window).height() - 553 );
    // if the URL contains a version string, update the version picker to reflect that
    version = document.location.pathname.match(/^\/(v\d\.\d)\/.*/)
    if (version && version[1]) {
        $('#document-version-number')[0].text = 'Version '+version[1];
    } else {
        $('#document-version-number')[0].text = $('#document-version-number')[0].text + " (Latest)"
    }
    // load the complete versions list
    $.get("/versions.html_fragment", function( data ) {
    	$('#documentation-version-list').prepend(data);
	//remove any "/v1.1/" bits from front, so we can add the path to the version selection dropdown.
	path = document.location.pathname.replace(/^\/v\d\.\d/, "");
	$('#documentation-version-list a.version').each(function(i, e) {
		e.href = e.href+path;
		$(e).removeClass()
	});
    });

  })
  var userName = getCookie('docker_sso_username');
  if (userName) {
    $('.topmostnav_loggedout').hide();
    $('.topmostnav_loggedin').show();
    $('#logged-in-header-username').text(userName);
  } else {
    $('.topmostnav_loggedout').show();
    $('.topmostnav_loggedin').hide();
  }
</script>
</body>
</html>